* COPYRIGHT (c) 1988 AEA Technology
*######DATE 21 Dec 1992
C       Toolpack tool decs employed.
C
C  EAT 21/6/93 EXTERNAL statement put in for block data on VAXs.
C
C 28/6/94 error found in MC43D and MC43K.
C In MC43D, the loop
C     DO 120 I = 1,N
C        ELEMP(I) = 0
C  120 CONTINUE
C should be
C      DO 120 I = 1,NSUP
C        ELEMP(I) = 0
C  120 CONTINUE
C and similarly in MC43K. Note ELEMP is of length NZ and
C provided each element has at least one variable, NZ.GE.NSUP
C

C 21 MAY 1996 : the following do loops have been commented out.
C               (They are unnecessary initialisation do loops
C                and if LIW is v. large, (*) and (**) add significantly
C                to the cost).
C      DO 10 I = 1,LIW
C        IW(I) = 0                 (*)
C   10 CONTINUE
C      DO 50 I = 1,NELT
C        NORDER(I) = 0
C   50 CONTINUE
C      DO 60 I = 1,N3
C        IW(I) = 0
C   60 CONTINUE
C      DO 20 J = 1,LENIRN
C        IRN(J) = 0                (**)
C   20 CONTINUE
C      DO 10 I = 1,3*N + 2
C        IW(I) = 0
C   10 CONTINUE
C      DO 20 I = 1,2*NSUP + N
C        IW1(I) = 0
C   20 CONTINUE
C      DO 30 I = 1,N
C        IW(I) = 0
C   30 CONTINUE
C      DO 20 I = 1,N
C        IW(I) = 0
C   20 CONTINUE
C
C 6 Oct. 1997 : bug found in MC43H/HD
C Replace:
C     INSERT STARTING NODE IN QUEUE
C     NQ IS THE SIZE OF QUEUE
C
C      NQ = 1
C      QUEUE(NQ) = NSTRT
C      PRIOR(NQ) = 1
C by
C     INSERT STARTING NODE IN QUEUE
C     NQ IS THE SIZE OF QUEUE
C
C      NQ = 1
C      QUEUE(NQ) = NSTRT
C      PRIOR(NSTRT) = 1
C
C 3 March 1998 : bug found in MC43R/RD
C Extra line added
C        IF (JSTOP.LE.JSTRT) GO TO 30

C 3 March 1998 : change made to MC43Q/QD
C Found     MAXDEG = NODES*NTOT   could get too large for big problems
C so compute MAXDEG explicitly in following do loop
C      MAXDEG = 0
C      DO 20 I = 1,NODES
C        NODE = NLIST(I)
C        DEGREE = 1
C        DO 10 J = ICPTR(NODE),ICPTR(NODE+1) - 1
C          K = IRN(J)
C          DEGREE = DEGREE + NSVAR(K)
C   10   CONTINUE
C        MAXDEG = MAX(MAXDEG,DEGREE)
C        PRIOR(NODE) = -W1*DEGREE + W2*STATUS(NODE)
C        STATUS(NODE) = 2
C   20 CONTINUE

C 2 April 1998 : change made to MC43P/PD
C Found     MINDEG = N*NTOT   could get too large for big problems
C so set MINDEG = 0 and then altered loop for finding NSTRT

C 8 June 1998 : if ICNTL = 0 then need workspace of length 2N for
C MC43S/SD. Hence LIW must be MAX(2*N,3*NZ + 2*NELT + N + 4)


      SUBROUTINE MC43AD(ICNTL,N,NELT,NZ,ELTVAR,ELTPTR,NORDER,LIW,IW,
     +                 MXWAVE,IFLAG)
C
C    GIVEN THE STRUCTURE OF AN UNASSEMBLED FINITE ELEMENT MATRIX,
C    REORDER THE ELEMENTS TO GIVE AN EFFICIENT ORDERING TO USE WITH
C    A FRONTAL SOLVER.
C    THE USER SPECIFIES WHETHER THE INDIRECT OR DIRECT ELEMENT
C    REORDERING ALGORITHM IS TO BE EMPLOYED.
C    THE CODE USES SOME SUBROUTINES WHICH ARE TAKEN FROM THE
C    HARWELL CODE MC40 (BUT RENAMED HERE).
C
C*********************************************************************
C ICNTL - INTEGER VARIABLE
C       - ON ENTRY SET ICNTL = 0 OR 1. IF ICNTL=0 THE DIRECT REORDERING
C         ALGORITHM IS USED; IF ICNTL=1 THE INDIRECT REORDERING
C         ALGORITHM IS EMPLOYED. THIS ARGUMENT IS NOT CHANGED.
C N     - INTEGER VARIABLE
C       - MUST BE SET TO THE LARGEST INTEGER USED TO INDEX A VARIABLE.
C       - THIS ARGUMENT IS NOT CHANGED.
C NELT  - INTEGER VARIABLE
C       - MUST BE SET TO THE NUMBER OF ELEMENTS AND IS NOT CHANGED
C NZ    - INTEGER VARIABLE
C       - MUST BE SET TO THE ELTPTR(NELT+1)-1 AND IS NOT CHANGED
C ELTVAR - INTEGER ARRAY. ON ENTRY, MUST BE SET TO LISTS OF
C        - VARIABLES IN ELEMENTS. THOSE FOR ELEMENT 1 PRECEDE THOSE FOR
C        - ELEMENT 2 AND SO ON.  UNCHANGED ON EXIT
C ELTPTR - INTEGER ARRAY.  ON ENTRY, ELTPTR(J) MUST CONTAIN THE
C        - POSITION IN ELTVAR OF THE FIRST VARIABLE IN ELEMENT J
C        - (J=1,...,NELT) AND ELTADJ(NELT+1) MUST BE SET TO THE POSITION
C        - AFTER THE LAST VARIABLE OF THE LAST ELEMENT.  UNCHANGED ON
C        - EXIT.
C NORDER - INTEGER ARRAY OF LENTH NELT. NOT SET ON ENTRY.
C        - ON EXIT, THE ORDER IN WHICH THE ELEMENTS SHOULD BE PRESENTED
C        - TO THE FRONTAL SOLVER IS NORDER(1), NORDER(2),...,
C        - NORDER(NELT).
C LIW    - INTEGER VARIABLE DEFINING LENGTH OF WORKSPACE.
C IW     - INTEGER ARRAY USED AS WORKSPACE. LENGTH OF ARRAY IS LIW.
C MXWAVE - INTEGER ARRAY OF LENGTH 2. NOT SET ON ENTRY.
C        - ON EXIT, MXWAVE(1) AND MXWAVE(2) ARE SET TO THE
C        - MAXIMUM WAVEFRONTS IN THE FRONTAL SOLVER
C        - (ASSUMING NO STABILITY RESTRICTIONS) FOR THE GIVEN
C        - ELEMENT ORDER AND THE NEW ELEMENT ORDER, RESPECTIVELY.
C IFLAG  - INTEGER VARIABLE. NOT SET ON ENTRY. ON EXIT, A VALUE OF 0
C        - INDICATES THE ROUTINE HAS BEEN PERFORMED SUCCESSFULLY.
C        - A NEGATIVE VALUE INDICATES A FATAL ERROR.
C*********************************************************************
C
C     .. Scalar Arguments ..
      INTEGER ICNTL,IFLAG,LIW,N,NELT,NZ
C     ..
C     .. Array Arguments ..
      INTEGER ELTPTR(NELT+1),ELTVAR(NZ),IW(LIW),MXWAVE(2),NORDER(NELT)
C     ..
C     .. Local Scalars ..
      INTEGER I,IELT,J,K,N1,N2,N3
C     ..
C     .. External Subroutines ..
      EXTERNAL MC43BD,MC43CD,MC43SD
C     ..
C     .. Data block external statement
      EXTERNAL MC43UD
C     ..
C     .. Intrinsic Functions ..
      INTRINSIC MAX
C     ..
C     .. Common blocks ..
      COMMON /MC43TD/LP,IWUSE(2)
      INTEGER LP
      INTEGER IWUSE
C     ..
C     .. Save statement ..
      SAVE /MC43TD/
C     ..
C     .. Executable Statements ..
C   INITIALISE
      IFLAG = 0
C      DO 10 I = 1,LIW
C        IW(I) = 0
C   10 CONTINUE
C
C  CHECK THE USER-SUPPLIED DATA
C
      IF (N.LT.1) THEN
        IFLAG = -1
        IF (LP.GT.0) WRITE (LP,FMT=9000) IFLAG
        RETURN

      END IF

      IF (NELT.LT.1) THEN
        IFLAG = -2
        IF (LP.GT.0) WRITE (LP,FMT=9000) IFLAG
        RETURN

      END IF

      IF (NELT.EQ.1) THEN
        NORDER(1) = 1
        MXWAVE(1) = 1
        MXWAVE(2) = 1
        RETURN

      END IF

      IF (NZ.LT.1) THEN
        IFLAG = -3
        IF (LP.GT.0) WRITE (LP,FMT=9000) IFLAG
        RETURN

      END IF

      IF (ICNTL.NE.0 .AND. ICNTL.NE.1) THEN
        IFLAG = -4
        IF (LP.GT.0) WRITE (LP,FMT=9000) IFLAG
        RETURN

      END IF
C
      DO 30 IELT = 1,NELT
        DO 20 J = ELTPTR(IELT),ELTPTR(IELT+1) - 1
          K = ELTVAR(J)
          IF (K.GT.N .OR. K.LT.1) THEN
            IFLAG = -6
            IF (LP.GT.0) WRITE (LP,FMT=9000) IFLAG
            RETURN

          END IF

   20   CONTINUE
   30 CONTINUE
C
C CHECK THE USER HAS SUPPLIED AT LEAST THE MINIMUM AMOUNT OF
C WORKSPACE REQUIRED
      IF (ICNTL.EQ.0) IWUSE(1) = MAX(2*N,3*NZ + 2*NELT + N + 4)
      IF (ICNTL.EQ.1) IWUSE(1) = MAX(3*NZ+NELT+N+3,NELT+64)
      IF (LIW.LT.IWUSE(1)) THEN
        IFLAG = -5
        IWUSE(2) = -1
        IF (LP.GT.0) THEN
          WRITE (LP,FMT=9000) IFLAG
          WRITE (LP,FMT=9010)
          WRITE (LP,FMT=9020) LIW,IWUSE(1)
        END IF

        RETURN

      END IF
C
C  FIND THE MAX WAVEFRONT FOR THE ORIGINAL ELEMENT ORDER
C
      DO 40 I = 1,NELT
        NORDER(I) = I
   40 CONTINUE
      N1 = 1
      N2 = N1 + N
      N3 = N2 + N
C MC43S/SD needs 2 arrays of length N
      CALL MC43SD(N,NELT,NZ,ELTVAR,ELTPTR,NORDER,IW(N1),IW(N2),
     +            MXWAVE(1))
C      DO 50 I = 1,NELT
C        NORDER(I) = 0
C   50 CONTINUE
C      DO 60 I = 1,N3
C        IW(I) = 0
C   60 CONTINUE
C
C  REORDER THE ELEMENTS
C
      IF (ICNTL.EQ.0) CALL MC43BD(N,NELT,NZ,ELTVAR,ELTPTR,NORDER,LIW,IW,
     +                           IFLAG)
      IF (ICNTL.EQ.1) CALL MC43CD(N,NELT,NZ,ELTVAR,ELTPTR,NORDER,LIW,IW,
     +                           IFLAG)
      IF (IFLAG.LT.0) RETURN
C
C  FIND THE MAX WAVEFRONT FOR THE NEW ELEMENT ORDER
C
      CALL MC43SD(N,NELT,NZ,ELTVAR,ELTPTR,NORDER,IW(N1),IW(N2),
     +            MXWAVE(2))
C
C  CHECK THAT THE REORDERING HAS REDUCED THE MAX WAVEFRONT.
C  IF NOT, SET NORDER(I)=I (I.E. RETAIN ORIGINAL ELEMENT ORDER)
C
      IF (MXWAVE(1).LE.MXWAVE(2)) THEN
        DO 70 I = 1,NELT
          NORDER(I) = I
   70   CONTINUE
        MXWAVE(2) = MXWAVE(1)
      END IF

 9000 FORMAT (/,3X,'ERROR MESSAGE FROM MC43AD: IFLAG = ',I2)
 9010 FORMAT (3X,'THE WORKSPACE PROVIDED BY THE USER IS LESS THAN',
     +       ' THE MINIMUM AMOUNT REQUIRED')
 9020 FORMAT (3X,'INCREASE LIW FROM ',I8,' TO AT LEAST ',I8)

      RETURN

      END
C**************************************************************
      SUBROUTINE MC43BD(N,NELT,NZ,ELTVAR,ELTPTR,NORDER,LIW,IW,IFLAG)
C
C    GIVEN THE STRUCTURE OF AN UNASSEMBLED FINITE ELEMENT MATRIX,
C    REORDER THE ELEMENTS TO GIVE AN EFFICIENT ORDERING TO USE WITH
C    A FRONTAL SOLVER.
C  *** DIRECT ELEMENT REORDERING ALGORITHM ****
C
C*********************************************************************
C N     - INTEGER VARIABLE
C       - MUST BE SET TO THE LARGEST INTEGER USED TO INDEX A VARIABLE.
C       - THIS ARGUMENT IS NOT CHANGED.
C NELT  - INTEGER VARIABLE
C       - MUST BE SET TO THE NUMBER OF ELEMENTS AND IS NOT CHANGED
C NZ    - INTEGER VARIABLE
C       - MUST BE SET TO THE ELTPTR(NELT+1)-1 AND IS NOT CHANGED
C ELTVAR - INTEGER ARRAY. ON ENTRY, MUST BE SET TO LISTS OF
C        - VARIABLES IN ELEMENTS. THOSE FOR ELEMENT 1 PRECEDE THOSE FOR
C        - ELEMENT 2 AND SO ON.  UNCHANGED ON EXIT
C ELTPTR - INTEGER ARRAY.  ON ENTRY, ELTPTR(J) MUST CONTAIN THE
C        - POSITION IN ELTVAR OF THE FIRST VARIABLE IN ELEMENT J
C        - (J=1,...,NELT) AND ELTADJ(NELT+1) MUST BE SET TO THE POSITION
C        - AFTER THE LAST VARIABLE OF THE LAST ELEMENT.  UNCHANGED ON
C        - EXIT.
C NORDER - INTEGER ARRAY OF LENTH NELT. NOT SET ON ENTRY.
C        - ON EXIT, THE ORDER IN WHICH THE ELEMENTS SHOULD BE PRESENTED
C        - TO THE FRONTAL SOLVER IS NORDER(1), NORDER(2),...,
C        - NORDER(NELT).
C LIW    - INTEGER VARIABLE DEFINING LENGTH OF WORKSPACE.
C IW     - INTEGER ARRAY USED AS WORKSPACE. LENGTH OF ARRAY IS LIW.
C IFLAG  - INTEGER VARIABLE. NOT SET ON ENTRY. ON EXIT, A VALUE OF 0
C        - INDICATES THE ROUTINE HAS BEEN PERFORMED SUCCESSFULLY.
C        - A NEGATIVE VALUE INDICATES A FATAL ERROR.
C*********************************************************************
C
C     .. Scalar Arguments ..
      INTEGER IFLAG,LIW,N,NELT,NZ
C     ..
C     .. Array Arguments ..
      INTEGER ELTPTR(NELT+1),ELTVAR(NZ),IW(LIW),NORDER(NELT)
C     ..
C     .. Local Scalars ..
      INTEGER I,IUSED,IUSEE,K,LNGTH,N1,N2,N3,N4,N5,N6,N7,NNZ,NSUP
C     ..
C     .. External Subroutines ..
      EXTERNAL MC43DD,MC43ED
C     ..
C     .. Intrinsic Functions ..
      INTRINSIC MAX
C     ..
C     .. Common blocks ..
      COMMON /MC43TD/LP,IWUSE(2)
      INTEGER LP
      INTEGER IWUSE
C     ..
C     .. Save statement ..
      SAVE /MC43TD/
C     ..
C     .. Executable Statements ..
C  DIVIDE UP THE WORKSPACE.
C
      IUSED = 3 + 2*NELT + 3*NZ + N
      LNGTH = LIW - IUSED
      N1 = 1
      N2 = N1 + NELT + 1
      N3 = N2 + NZ
      N4 = N3 + NELT + 1
      N5 = N4 + NZ
      N6 = N5 + LNGTH
      N7 = N6 + NZ
C
C  CONSTRUCT THE ELEMENT CONNECTIVITY GRAPH AND SUPERVARIABLE LISTS
C
      CALL MC43DD(N,NELT,NZ,NNZ,NSUP,ELTVAR,ELTPTR,IW(N5),IW(N1),IW(N7),
     +           IW(N4),IW(N2),IW(N3),IW(N6),LNGTH,IFLAG)
      IF (IFLAG.LT.0) THEN
        IWUSE(1) = IWUSE(1) + IUSED
        IUSEE = 5 + NZ + 6*NELT + 3*N + 2*NNZ
        IWUSE(2) = MAX(IUSEE,IWUSE(1))
        GO TO 40

      END IF

      IWUSE(1) = IUSED + 2*NNZ
C
      DO 10 I = 1,NNZ
        IW(N4+NSUP+I-1) = IW(N5+I-1)
   10 CONTINUE
      N5 = N4 + NSUP
      N6 = N5 + 2*NNZ
      N7 = N6 + 3*NELT + 2
      IUSEE = 5 + NZ + 6*NELT + 3*NSUP + 2*NNZ
      IF (IUSEE.GT.LIW) THEN
C INSUFFICIENT WORKSPACE TO RUN MC43ED
        IFLAG = -5
        IWUSE(1) = IUSEE
        IWUSE(2) = IUSEE
        GO TO 40

      END IF

      IWUSE(1) = MAX(IWUSE(1),IUSEE)
      CALL MC43ED(NELT,N,NSUP,NNZ,NZ,IW(N2),IW(N3),IW(N4),IW(N5),IW(N1),
     +           NORDER,IW(N6),IW(N7))
      DO 20 I = 1,NELT
        IW(I) = NORDER(I)
   20 CONTINUE
      DO 30 I = 1,NELT
        K = IW(I)
        NORDER(K) = I
   30 CONTINUE
      GO TO 50

   40 IF (LP.GT.0) THEN
        WRITE (LP,FMT=9000) IFLAG
        WRITE (LP,FMT=9010) LIW,IWUSE(1)
        WRITE (LP,FMT=9020) IWUSE(2)
      END IF

 9000 FORMAT (/,3X,'ERROR MESSAGE FROM MC43A: IFLAG = ',I2)
 9010 FORMAT (3X,'INCREASE LIW FROM ',I8,' TO AT LEAST ',I8)
 9020 FORMAT (3X,'UPPER BOUND FOR LIW IS   ',I8)

   50 RETURN

      END
C****************************************************************
      SUBROUTINE MC43CD(N,NELT,NZ,ELTVAR,ELTPTR,NORDER,LIW,IW,IFLAG)
C
C    GIVEN THE STRUCTURE OF AN UNASSEMBLED FINITE ELEMENT MATRIX,
C    REORDER THE ELEMENTS TO GIVE AN EFFICIENT ORDERING TO USE WITH
C    A FRONTAL SOLVER.
C  **** INDIRECT ELEMENT REORDERING ALGORITHM ****
C
C
C N     - INTEGER VARIABLE
C       - MUST BE SET TO THE LARGEST INTEGER USED TO INDEX A VARIABLE.
C       - THIS ARGUMENT IS NOT CHANGED.
C       - RESTRICTION : N_GE_1.
C NELT  - INTEGER VARIABLE
C       - MUST BE SET TO THE NUMBER OF ELEMENTS AND IS NOT CHANGED
C       - RESTRICTION : NELT_GE_1.
C NZ    - INTEGER VARIABLE
C       - MUST BE SET TO THE ELTPTR(NELT+1)-1 AND IS NOT CHANGED
C       - RESTRICTION : NZ_GE_1.
C ELTVAR - INTEGER ARRAY. ON ENTRY, MUST BE SET TO LISTS OF
C        - VARIABLES IN ELEMENTS. THOSE FOR ELEMENT 1 PRECEDE THOSE FOR
C        - ELEMENT 2 AND SO ON.  UNCHANGED ON EXIT
C ELTPTR - INTEGER ARRAY.  ON ENTRY, ELTPTR(J) MUST CONTAIN THE
C        - POSITION IN ELTVAR OF THE FIRST VARIABLE IN ELEMENT J
C        - (J=1,...,NELT) AND ELTADJ(NELT+1) MUST BE SET TO THE POSITION
C        - AFTER THE LAST VARIABLE OF THE LAST ELEMENT.  UNCHANGED ON
C        - EXIT.
C NORDER - INTEGER ARRAY OF LENTH NELT. NOT SET ON ENTRY.
C        - ON EXIT, THE ORDER IN WHICH THE ELEMENTS SHOULD BE PRESENTED
C        - TO THE FRONTAL SOLVER IS NORDER(1), NORDER(2),...,
C        - NORDER(NELT).
C LIW    - INTEGER VARIABLE. DEFINES THE LENGTH OF THE WORK ARRAY IW.
C        - UNCHANGED ON EXIT
C IW     - INTEGER ARRAY OF LENGTH LIW. USED AS WORKSPACE.
C IFLAG  - INTEGER VARIABLE. NOT SET ON ENTRY. ON EXIT, A VALUE OF 0
C        - INDICATES THE ROUTINE HAS BEEN PERFORMED SUCCESSFULLY.
C        - A NEGATIVE VALUE INDICATES A FATAL ERROR.
C*********************************************************************
C
C     .. Scalar Arguments ..
      INTEGER IFLAG,LIW,N,NELT,NZ
C     ..
C     .. Array Arguments ..
      INTEGER ELTPTR(NELT+1),ELTVAR(NZ),IW(LIW),NORDER(NELT)
C     ..
C     .. Local Scalars ..
      INTEGER I,IUSE,IUSEL,J1,J2,LNGTH,N1,N2,N3,N4,N5,N6,N7,NFRE,NNZ,
     +        NSUP
C     ..
C     .. External Subroutines ..
      EXTERNAL MC43KD,MC43LD,MC43MD,MC43ND,MC43OD
C     ..
C     .. Intrinsic Functions ..
      INTRINSIC MAX
C     ..
C     .. Common blocks ..
      COMMON /MC43TD/LP,IWUSE(2)
      INTEGER LP
      INTEGER IWUSE
C     ..
C     .. Save statement ..
      SAVE /MC43TD/
C     ..
C     .. Executable Statements ..
C  DIVIDE UP THE WORKSPACE.
C
      N1 = 1
      N2 = N1 + NZ
      N3 = N2 + NELT + 1
      N4 = N3 + NZ
      N5 = N4 + NZ
      N6 = N5 + N
C
C  CONSTRUCT THE SUPERVARIABLE LISTS
C
      CALL MC43KD(N,NELT,NZ,ELTVAR,ELTPTR,NSUP,IW(N5),IW(N3),IW(N1),
     +           IW(N2),IW(N4))
C
C  CONSTRUCT THE SUPERVARIABLE CONNECTIVITY GRAPH
C
C  DETERMINE SPACE AVAILABLE FROM IW FOR THE ARRAY IN WHICH TO
C  STORE THE ENTRIES IN THE SUPERVARIABLE CONNECTIVITY GRAPH.
C
      IUSE = 5 + NZ + NELT + 6*NSUP
      IF (IUSE.GE.LIW) THEN
C NO SPACE AVAILABLE. TRY AND FIND OUT AMOUNT NEEDED AND RETURN
C TO THE USER.
        IFLAG = -5
        IUSEL = 3 + NZ + NELT + 3*NSUP
C  RUN MC43LD ADDING UP SPACE REQUIRED
        LNGTH = LIW - IUSEL
        N4 = N3 + NSUP
        N5 = N4 + NSUP + 1
        N6 = N5 + LNGTH
        N7 = N6 + NSUP
        CALL MC43LD(NSUP,NELT,NNZ,IW(N1),IW(N2),IW(N4),IW(N5),LNGTH,
     +             IW(N6),IFLAG)
        IWUSE(1) = IWUSE(1) + IUSE
        GO TO 20

      END IF
C
C  ASSIGN LNGTH TO AVAILABLE WORKSPACE
      LNGTH = LIW - IUSE
      N4 = N3 + NSUP
      N5 = N4 + NSUP + 1
      N6 = N5 + LNGTH
      N7 = N6 + NSUP
      CALL MC43LD(NSUP,NELT,NNZ,IW(N1),IW(N2),IW(N4),IW(N5),LNGTH,
     +           IW(N6),IFLAG)
      IF (IFLAG.LT.0) THEN
        IWUSE(1) = IWUSE(1) + IUSE
        GO TO 20

      END IF

      IWUSE(1) = MAX(IUSE+2*NNZ,IWUSE(1))
C
C  RENUMBER THE SUPERVARIABLE CONNECTIVITY GRAPH
C
      N7 = N6 + 3*NSUP + 2
      CALL MC43MD(NSUP,NNZ,N,IW(N5),IW(N4),IW(N3),IW(N7),IW(N6))
C
C  FIND THE LOWEST NUMBERED SUPERVARIABLE IN EACH ELEMENT
C
      CALL MC43ND(NSUP,NELT,NZ,IW(N1),IW(N2),IW(N7),IW(N3),NORDER)
C
C  RESEQUENCE THE ELEMENTS
C
      DO 10 I = 1,NELT
        IW(I) = IW(N3+I-1)
   10 CONTINUE
      N1 = 1
      N2 = N1 + NELT
      N3 = N2 + 64
      CALL MC43OD(NELT,NORDER,IW(N1),IW(N2))
   20 IF (IFLAG.LT.0) THEN
C    FIND AN UPPER BOUND ON SPACE REQUIRED FOR IW.
C       (IF EACH NODE HAS MORE THAN ONE FREEDOM THIS MAY BE
C        A GROSS OVERESTIMATE)
        J1 = 0
        DO 30 I = 1,NELT
          J2 = IW(N2+I) - IW(N2+I-1)
          IF (J2.GT.J1) J1 = J2
   30   CONTINUE
        NFRE = J1
        IWUSE(2) = 3 + 3* (N+NZ) + NELT* (1+NFRE*NFRE)
        IWUSE(1) = MAX(IWUSE(1),NELT+64)
        IWUSE(2) = MAX(IWUSE(2),NELT+64)
        IF (LP.GT.0) THEN
          WRITE (LP,FMT=9000) IFLAG
          WRITE (LP,FMT=9010) LIW,IWUSE(1)
          WRITE (LP,FMT=9020) IWUSE(2)
        END IF

        RETURN

      END IF

 9000 FORMAT (/,3X,'ERROR MESSAGE FROM MC43A: IFLAG = ',I2)
 9010 FORMAT (3X,'INCREASE LIW FROM ',I8,' TO AT LEAST ',I8)
 9020 FORMAT (3X,'UPPER BOUND FOR LIW IS  ',I8)

      RETURN

      END
C*********************************************************************
      SUBROUTINE MC43DD(N,NELT,NZ,NNZ,NSUP,ELTVAR,ELTPTR,ELTADJ,ADJPTR,
     +                 VAR,NSVAR,SELTVR,SELTPR,ELEMP,LNGTH,IFLAG)
C
C   GIVEN THE STRUCTURE OF AN UNASSEMBLED FINITE ELEMENT MATRIX, FIND
C   ELEMENT ADJACENCY LISTS AND GROUP THE VARIABLES INTO SUPERVARIABLES
C   (EACH VARIABLE IN A SUPERVARIABLE BELONGS TO THE SAME SET OF
C   ELEMENTS).
C   ORDERING IS BY COLUMNS SO THAT THE OUTPUT MAY BE USED IN THE
C   CODE MC34.
C*********************************************************************
C N     - INTEGER VARIABLE
C       - MUST BE SET TO THE LARGEST INTEGER USED TO INDEX A VARIABLE.
C       - THIS ARGUMENT IS NOT CHANGED.
C NELT - INTEGER VARIABLE
C      - MUST BE SET TO THE NUMBER OF ELEMENTS AND IS NOT CHANGED
C NZ    - INTEGER VARIABLE
C       - MUST BE SET TO THE ELTPTR(NELT+1)-1 AND IS NOT CHANGED
C NNZ  - INTEGER VARIABLE
C      - NOT SET ON ENTRY. ON EXIT SET TO ADJPTR(NELT+1)-1.
C ELTVAR - INTEGER ARRAY. ON ENTRY, MUST BE SET TO LISTS OF
C        - VARIABLES IN ELEMENTS. THOSE FOR ELEMENT 1 PRECEDE THOSE FOR
C        - ELEMENT 2 AND SO ON.  UNCHANGED ON EXIT
C ELTPTR - INTEGER ARRAY.  ON ENTRY, ELTPTR(J) MUST CONTAIN THE
C        - POSITION IN ELTVAR OF THE FIRST VARIABLE IN ELEMENT J
C        - (J=1,...,NELT) AND ELTADJ(NELT+1) MUST BE SET TO THE POSITION
C        - AFTER THE LAST VARIABLE OF THE LAST ELEMENT.  UNCHANGED ON
C        - EXIT.
C ELTADJ - INTEGER ARRAY. NEED NOT BE SET ON ENTRY. ON
C        - RETURN, SET TO LISTS OF ADJACENT ELEMENTS.  THOSE FOR
C        - ELEMENT 1 PRECEDE THOSE FOR ELEMENT 2 AND SO ON. ONLY THOSE
C        - WITH LOWER INDICES ARE INCLUDED.
C        - ARRAY IS OF LENGTH LNGTH
C ADJPTR - INTEGER ARRAY. NEED NOT BE SET ON ENTRY. ON RETURN,
C        - ADJPTR(J) CONTAINS THE POSITION IN ELTADJ OF THE FIRST
C        - ADJACENT ELEMENT FOR ELEMENT J (J=1,...,NELT) AND
C        - ADJPTR(NELT+1) CONTAINS THE POSITION AFTER THE LAST
C        - ADJACENCY FOR THE LAST ELEMENT.
C        - ARRAY MUST BE OF LENGTH NELT+1
C VAR    - INTEGER ARRAY. NEED NOT BE SET ON ENTRY. ON RETURN, VAR(I)
C        - CONTAINS THE SUPERVARIABLE TO WHICH VARIABLE BELONGS,
C        - I=1,...,N.
C NSVAR  - INTEGER ARRAY. NEED NOT BE SET ON ENTRY. ON RETURN, NSVAR(I)
C        - CONTAINS THE NUMBER OF VARIABLES IN SUPERVARIABLE I,
C        - I=1,...,NSUP.
C        - ARRAY IS LENGTH NZ
C SELTVR - INTEGER ARRAY. NOT SET ON ENTRY. ON EXIT CONTAINS
C        - LISTS OF SUPERVARAIBLES IN THE ELEMENTS. THOSE FOR
C        - ELEMENT 1 PRECEDE THOSE FOR ELEMENT 2, AND SO ON.
C SELTPR - INTEGER ARRAY OF LENGTH NELT+1.
C        - NOT SET ON ENTRY. ON EXIT, SELTPR(J) CONTAINS THE POSITION
C        - IN SELTVR OF THE FIRST SUPERVARIABLE IN ELEMENT J
C        - (J=1,...,NELT), AND SELTPR(NELT+1) IS SET TO THE POSITION
C        - AFTER THE LAST SUPERVARIABLE IN THE LAST ELEMENT.
C ELEMP  - INTEGER ARRAY OF LENGTH NZ. USED FOR WORKSPACE.
C LNGTH  - INTEGER VARIABLE DEFINING LENGTH OF ARRAY ELTADJ
C        - UNCHANGED ON EXIT.
C IFLAG  - INTEGER VARIABLE.
C        - SET ON ENTRY BY MC43A. UNCHANGED ON EXIT UNLESS ERROR
C        - IS ENCOUNTERED.
C********************************************************************
C     .. Scalar Arguments ..
      INTEGER IFLAG,LNGTH,N,NELT,NNZ,NSUP,NZ
C     ..
C     .. Array Arguments ..
      INTEGER ADJPTR(NELT+1),ELEMP(NZ),ELTADJ(LNGTH),ELTPTR(NELT+1),
     +        ELTVAR(NZ),NSVAR(NZ),SELTPR(NELT+1),SELTVR(NZ),VAR(N)
C     ..
C     .. Local Scalars ..
      INTEGER END,I,IE,IELT,ISUP,J,J1,J2,K,KADJ,KDUMMY,KE,L,M,M1,START
C     ..
C     .. Common blocks ..
      COMMON /MC43TD/LP,IWUSE(2)
      INTEGER LP
      INTEGER IWUSE
C     ..
C     .. Save statement ..
      SAVE /MC43TD/
C     ..
C     .. Executable Statements ..
C
C  INITIALIZE VAR AND SELTPR
      DO 10 I = 1,N
        VAR(I) = 0
   10 CONTINUE
      DO 20 I = 1,NELT
        SELTPR(I) = 0
   20 CONTINUE
C
C CONSTRUCT THE ELEMENT ADJACENCY LISTS
C IN THIS LOOP, SUPERVARIABLE K TOUCHES ELEMENTS NSVAR(K),
C NSVAR(ELEMP(K)), NSVAR(ELEMP(ELEMP(K))),...; THE SUPERVARIABLES
C FOR THE CURRENT ELEMENT RUN FROM START TO END.
      END = 0
      DO 60 IE = NELT,1,-1
        START = END + 1
        DO 50 I = ELTPTR(IE),ELTPTR(IE+1) - 1
          M = ELTVAR(I)
          K = VAR(M)
C  JUMP IF WE ALREADY HAVE THE SUPERVARIABLE
          DO 30 L = START,END
            IF (ELEMP(L).EQ.K) GO TO 40
   30     CONTINUE
C CREATE NEW SUPERVARIABLE
          END = END + 1
          NSVAR(END) = IE
          ELEMP(END) = K
          L = END
C STORE VARIABLE TO SUPERVARIABLE POINTER
   40     VAR(M) = L
   50   CONTINUE
   60 CONTINUE
C
      KADJ = 1
      DO 90 IE = 1,NELT
        ADJPTR(IE) = KADJ
        M1 = END
        DO 80 M = M1,1,-1
          IF (NSVAR(M).EQ.IE) THEN
            END = END - 1

          ELSE
            GO TO 90

          END IF

          K = ELEMP(M)
C ADD TO ELEMENT ADJACENCY LIST
          DO 70 KDUMMY = 1,END
            IF (K.EQ.0) GO TO 80
            KE = NSVAR(K)
            K = ELEMP(K)
            IF (KE.EQ.IE) GO TO 70
            IF (SELTPR(KE).EQ.IE) GO TO 70
            SELTPR(KE) = IE
            IF (KADJ*2.GT.LNGTH) IFLAG = -5
            IF (IFLAG.NE.-5) ELTADJ(KADJ) = KE
            KADJ = KADJ + 1
   70     CONTINUE
   80   CONTINUE
   90 CONTINUE
      ADJPTR(NELT+1) = KADJ
      NNZ = ADJPTR(NELT+1) - 1
      IWUSE(1) = 2*NNZ
      IF (IFLAG.EQ.-5) RETURN
C
C CONSTRUCT SUPERVARIABLES
C NSUP IS THE NUMBER OF SUPERVARIABLES
      NSUP = 0
      DO 110 M = 1,N
        L = VAR(M)
        IF (L.EQ.0) GO TO 110
        ISUP = -ELEMP(L)
        IF (ISUP.GT.0) GO TO 100
C WE HAVE A NEW SUPERVARIABLE
        NSUP = NSUP + 1
        NSVAR(NSUP) = 1
        VAR(M) = NSUP
        ELEMP(L) = -NSUP
        GO TO 110
C WE HAVE AN OLD SUPERVARIABLE
  100   NSVAR(ISUP) = NSVAR(ISUP) + 1
        VAR(M) = ISUP
  110 CONTINUE
C
C  SET UP ELEMENT SUPERVARIABLE LISTS
C
      DO 120 I = 1,NSUP
        ELEMP(I) = 0
  120 CONTINUE
      END = 0
      SELTPR(1) = 1
      DO 140 IELT = 1,NELT
        J1 = ELTPTR(IELT)
        J2 = ELTPTR(IELT+1) - 1
        SELTPR(IELT+1) = SELTPR(IELT)
        DO 130 J = J1,J2
          K = ELTVAR(J)
          K = VAR(K)
          IF (ELEMP(K).LT.IELT) THEN
            ELEMP(K) = IELT
            END = END + 1
            SELTVR(END) = K
            SELTPR(IELT+1) = SELTPR(IELT+1) + 1
          END IF

  130   CONTINUE
  140 CONTINUE
      RETURN

      END
C******************************************************************
      SUBROUTINE MC43ED(N,NTOT,NSUP,NNZ,NZ,SELTVR,SELTPR,NSVAR,IRN,
     +                 ICPTR,IPERM,IW,IW1)
C
C
C   N    - ORDER OF THE MATRIX (= NUMBER OF ELEMENTS IN GRID)
C        - UNCHANGED ON EXIT
C NNZ    - ON ENTRY, NNZ IS THE NUMBER OF ENTRIES IN THE STRICT
C          LOWER TRIANGLE OF THE MATRIX
C        - (= NUMBER OF EDGES IN ELEMENT CONNECTIVITY GRAPH)
C NTOT   - NUMBER OF VARIABLES IN THE PROBLEM
C        - UNCHANGED ON EXIT
C NSUP   - NUMBER OF SUPERVARIABLES IN THE PROBLEM
C        - UNCHANGED ON EXIT
C SELTVR - INTEGER ARRAY LENGTH NSUP.
C        - CONTAINS ELEMENT SUPERVARIABLE LISTS
C        - UNCHANGED ON EXIT
C SELTPR - INTEGER ARRAY LENGTH N+1
C        - ELEMENT POINTERS FOR SELTVR
C        - UNCHANGED ON EXIT
C NSVAR  - INTEGER ARRAY. NEED NOT BE SET ON ENTRY. ON RETURN, NSVAR(I)
C        - CONTAINS THE NUMBER OF VARIABLES IN SUPERVARIABLE I,
C        - I=1,...,NSUP.
C        - UNCHANGED ON EXIT
C IRN    - INTEGER ARRAY OF LENGTH 2*NNZ
C        - ON ENTRY, IRN CONTAINS THE ROW INDICES OF THE
C          ENTRIES IN THE STRICT LOWER TRIANGLE OF THE
C          MATRIX
C        - ON EXIT, IRN CONTAINS THE ROW INDICES FOR THE EXPANDED
C          MATRIX
C ICPTR  - INTEGER ARRAY OF LENGTH N+1
C        - ON ENTRY, SET SO THAT ICPTR(J) IS THE
C          POSITION IN THE ARRAY IRN OF THE FIRST ENTRY IN
C          COLUMN J (J=1,...,N)
C        - SAME MEANING ON EXIT
C IPERM  - INTEGER ARRAY. NOT SET ON ENTRY
C        - ON EXIT CONTAINS NEW ELEMENT NUMBERS
C   IW   - INTEGER ARRAY DEFINING WORKSPACE FOR RENUMBERING
C        - LENGTH OF ARRAY 3*N+2
C   IW1  - INTEGER WORKSPACE OF LENGTH 2*NSUP +N
C***********************************************************************
C
C     .. Scalar Arguments ..
      INTEGER N,NNZ,NSUP,NTOT,NZ
C     ..
C     .. Array Arguments ..
      INTEGER ICPTR(N+1),IPERM(N),IRN(2*NNZ),IW(3*N+2),IW1(2*NSUP+N),
     +        NSVAR(NSUP),SELTPR(N+1),SELTVR(NZ)
C     ..
C     .. Local Scalars ..
      INTEGER DEGREE,I,I1,I2,I3,LSTNUM,N1,N2,N3,NODES,NSTOP,NSTRT
      LOGICAL YESA
C     ..
C     .. Local Arrays ..
      DOUBLE PRECISION A(1)
C     ..
C     .. External Subroutines ..
      EXTERNAL MC34AD,MC43FD,MC43GD,MC43HD
C     ..
C     .. Executable Statements ..
      YESA = .FALSE.
C      DO 10 I = 1,3*N + 2
C       IW(I) = 0
C   10 CONTINUE
C      DO 20 I = 1,2*NSUP + N
C        IW1(I) = 0
C   20 CONTINUE
      CALL MC34AD(N,IRN,ICPTR,YESA,A,IW)
C      DO 30 I = 1,N
C        IW(I) = 0
C   30 CONTINUE
C
C THE RENUMBERING ALGORITHM
C     SET ALL NEW NODE NUMBERS = 1
C     THIS IS USED TO DENOTE ALL VISIBLE NODES
C
      DO 40 I = 1,N
        IPERM(I) = 1
   40 CONTINUE
C
C     SET LAST NEW NODE NUMBER
C
      LSTNUM = 0
C
C     RENUMBER ALL NODES OF DEGREE ZERO
C     STORE -VE OF NEW NODE NUMBER
C
      DO 50 I = 1,N
        DEGREE = ICPTR(I+1) - ICPTR(I)
        IF (DEGREE.EQ.0) THEN
          LSTNUM = LSTNUM + 1
          IPERM(I) = -LSTNUM
        END IF

   50 CONTINUE
C
C     LOOP WHILE SOME NODES REMAIN UNNUMBERED
C
   60 IF (LSTNUM.LT.N) THEN
C
C       FIND END POINTS OF P-DIAMETER FOR NODES IN THIS COMPONENT
C
        N1 = 1
        N2 = N1 + N - LSTNUM
        N3 = N2 + N + 1
        CALL MC43FD(N,NNZ,IRN,ICPTR,IPERM,IW(N1),IW(N2),IW(N2),IW(N3),
     +             NSTRT,NSTOP,NODES)
C
C       COMPUTE DISTANCES FROM END NODE AND ASSEMBLE LIST OF NODES
C       THAT ARE IN THIS COMPONENT
C
        N2 = N1 + NODES
        N3 = N2 + NODES + 1
        CALL MC43GD(N,NNZ,NSTOP,NODES,IRN,ICPTR,IPERM,IW(N1),IW(N2))
C
C       RENUMBER NODES IN THIS COMPONENT
C
        N3 = N2 + N
        I1 = 1
        I2 = I1 + NSUP
        I3 = I2 + NSUP
        CALL MC43HD(N,NNZ,NODES,NTOT,NSUP,NSTRT,LSTNUM,NSVAR,NZ,SELTVR,
     +             SELTPR,IRN,ICPTR,IPERM,IW(N1),IW(N1),IW(N2),IW1(I1),
     +             IW1(I2),IW1(I3))
        GO TO 60

      END IF
C
C     SET NEW NODE NUMBERS TO +VE VALUES
C
      DO 70 I = 1,N
        IPERM(I) = -IPERM(I)
   70 CONTINUE
      RETURN

      END
C***********************************************************************
      SUBROUTINE MC43FD(N,NNZ,IRN,ICPTR,MASK,LS,XLS,DEG,LIST,NSTRT,
     +                 NSTOP,NODES)
C
C
C  PURPOSE: FIND NODES WHICH DEFINE A PSUEDO-DIAMETER OF A GRAPH
C
C   N    - THE TOTAL NUMBER OF NODES IN THE GRAPH
C        - UNCHANGED ON EXIT
C  IRN   - ADJACENCY LIST FOR ALL NODES IN THE GRAPH
C        - UNCHANGED ON EXIT
C  ICPTR - LIST OF POINTERS TO  IRN
C        - NODES ADJACENT TO NODE 'I' ARE FOUND IN IRN(J), WHERE
C          J = ICPTR(I), ICPTR(I)+1, ...,ICPTR(I+1)-1
C        - LIST OF LENGTH N+1
C        - UNCHANGED ON EXIT
C  MASK  - MASKING VECTOR FOR GRAPH
C        - VISIBLE NODES HAVE MASK = 1
C        - NODE IS INVISIBLE OTHERWISE
C        - LIST OF LENGTH N
C        - UNCHANGED ON EXIT
C  LS    - LIST CONTAINING A ROOTED LEVEL STRUCTURE
C        - LIST OF LENGTH N
C        - NOT DEFINED WHEN CALLING ROUTINE
C  XLS   - LIST OF POINTERS TO LS
C        - NODES IN LEVEL 'I' ARE FOUND IN LS(J), WHERE
C          J = XLS(I), XLS(I)+1, ..., XLS(I+1)-1
C        - THE WIDTH OF LEVEL 'I' IS GIVEN BY XLS(I+1)-XLS(I)
C        - LIST OF MAX LENGTH N+1
C        - NOT DEFINED WHEN CALLING ROUTINE
C  DEG   - LIST OF DEGREES OF NODES ON BOTTOM LEVEL OF ROOTED
C          STRUCTURE
C        - LIST OF MIN LENGTH N
C        - NOT DEFINED WHEN CALLING ROUTINE
C  LIST  - LIST OF NODES ON BOTTOM LEVEL OF ROOTED LEVEL STRUCTURE
C        - LIST OF MAX LENGTH N
C        - NOT DEFINED WHEN CALLING ROUTINE
C  NSTRT - NOT SET ON ENTRY
C        - ON EXIT STARTING NODE FOR RENUMBERING
C  NSTOP - NOT SET ON ENTRY
C        - ON EXIT END NODE FOR RENUMBERING
C  NODES - NOT SET ON ENTRY
C        - ON EXIT THE NUMBER OF NODES IN THIS COMPONENT OF GRAPH
C NOTE:    - DEG AND XLS MAY OCCUPY SAME SPACE
C          - NSTRT AND NSTOP DEFINE A PSUEDO-DIAMETER OF THIS COMPONENT
C            OF THE GRAPH
C***********************************************************************
C     .. Scalar Arguments ..
      INTEGER N,NNZ,NODES,NSTOP,NSTRT
C     ..
C     .. Array Arguments ..
      INTEGER DEG(N),ICPTR(N+1),IRN(2*NNZ),LIST(N),LS(N),MASK(N),
     +        XLS(N+1)
C     ..
C     .. Local Scalars ..
      INTEGER DEGREE,I,ID1,ID2,ISTOP,ISTRT,LSIZE,LWIDTH,MAXDEP,MINDEG,
     +        MINWID,NLSIZE,NLVL,NODE
C     ..
C     .. External Subroutines ..
      EXTERNAL MC43ID,MC43JD
C     ..
C     .. Executable Statements ..
C
C     CHOOSE FIRST GUESS FOR STARTING NODE BY MIN DEGREE
C     IGNORE NODES THAT ARE INVISIBLE (MASK NE 1)
C
      MINDEG = N
      DO 10 I = 1,N
        IF (MASK(I).EQ.1) THEN
          DEGREE = ICPTR(I+1) - ICPTR(I)
          IF (DEGREE.LT.MINDEG) THEN
            NSTRT = I
            MINDEG = DEGREE
          END IF

        END IF

   10 CONTINUE
C
C     GENERATE LEVEL STRUCTURE FOR NODE WITH MIN DEGREE
C
      CALL MC43ID(N,NNZ,NSTRT,N,IRN,ICPTR,MASK,LS,XLS,MAXDEP,LWIDTH)
C
C     STORE NUMBER OF NODES IN THIS COMPONENT
C
      NODES = XLS(MAXDEP+1) - 1
C
C     ITERATE TO FIND START AND END NODES
C
   20 CONTINUE
C
C     STORE DEGREES OF NODES THAT ARE AT MAX DISTANCE FROM STARTING NODE
C
      ISTRT = XLS(MAXDEP)
      ISTOP = XLS(MAXDEP+1) - 1
      DO 30 I = ISTRT,ISTOP
        NODE = LS(I)
        DEG(NODE) = ICPTR(NODE+1) - ICPTR(NODE)
   30 CONTINUE
C
C     SORT LIST OF NODES IN ASCENDING SEQUENCE OF THEIR DEGREE
C     USE INSERTION SORT ALGORITHM (HOULSBY AND SLOAN)
C
      LSIZE = ISTOP - ISTRT + 1
      IF (LSIZE.GT.1) CALL MC43JD(N,LSIZE,LS(ISTRT),DEG)
C
C     STORE THE SORTED LIST
C
      ISTRT = ISTRT - 1
      DO 40 I = 1,LSIZE
        LIST(I) = LS(ISTRT+I)
   40 CONTINUE
      ID1 = DEG(LIST(1))
      NLSIZE = 1
      DO 50 I = 2,LSIZE
        ID2 = DEG(LIST(I))
        IF (ID2.NE.ID1) THEN
          NLSIZE = NLSIZE + 1
          LIST(NLSIZE) = LIST(I)
        END IF

        ID1 = ID2
   50 CONTINUE
C
C     LOOP OVER NODES IN LIST
C
      MINWID = NODES
      DO 60 I = 1,NLSIZE
        NODE = LIST(I)
C
C       FORM ROOTED LEVEL STRUCTURES FOR EACH NODE IN LIST
C
        CALL MC43ID(N,NNZ,NODE,MINWID,IRN,ICPTR,MASK,LS,XLS,NLVL,LWIDTH)
        IF ((NLVL.GT.MAXDEP) .AND. (LWIDTH.LT.MINWID)) THEN
C
C           LEVEL STRUCTURE OF GREATER DEPTH FOUND
C           STORE ROOT NODE AS STARTING NODE, NEW MAX DEPTH, AND BEGIN
C           A NEW ITERATION
C
          NSTRT = NODE
          MAXDEP = NLVL
          GO TO 20

        ELSE IF (LWIDTH.LT.MINWID) THEN
C
C             LEVEL STRUCTURE WIDTH FOR THIS END NODE IS SMALLEST
C             ENCOUNTERED SO FAR
C             STORE END NODE AND NEW MIN WIDTH
C
          NSTOP = NODE
          MINWID = LWIDTH
        END IF

   60 CONTINUE
      RETURN

      END
C***********************************************************************
      SUBROUTINE MC43GD(N,NNZ,ROOT,NODES,IRN,ICPTR,MASK,LS,XLS)
C
C
C PURPOSE: ASSEMBLE LIST OF NODES IN SAME COMPONENT AS ROOT NODE
C          COMPUTE DISTANCES OF THESE NODES FROM ROOT NODE
C
C      N       - TOTAL NUMBER OF NODES IN THE GRAPH
C              - UNCHANGED ON EXIT
C      ROOT    - THE ROOT NODE
C              - UNCHANGED ON EXIT
C      NODES   - THE NUMBER OF NODES IN SAME COMPONENT AS ROOT
C              - UNCHANGED ON EXIT
C      IRN     - ADJACENCY LIST FOR ALL NODES IN GRAPH
C              - UNCHANGED ON EXIT
C      ICPTR   - LIST OF POINTERS TO IRN
C              - UNCHANGED ON EXIT
C      MASK    - MASKING VECTOR FOR GRAPH
C              - VISIBLE NODES HAVE MASK = 1
C              - LIST OF LENGTH N
C              - ON EXIT,DISTANCES OF NODES IN THIS COMPONENT FROM ROOT
C              - THE DISTANCE OF NODE 'I' IS GIVEN BY MASK(I)
C      LS      - NOT SET ON ENTRY
C              - ON EXIT, LIST CONTAINING A ROOTED LEVEL STRUCTURE
C                (I.E. A LIST OF NODES IN THE SAME COMPONENT AS ROOT)
C              - LIST OF LENGTH NODES
C      XLS     - NOT SET ON ENTRY
C              - ON EXIT, LIST OF POINTERS TO LS
C              - NODES IN LEVEL 'I' ARE FOUND IN LS(J), WHERE
C                J = XLS(I), XLS(I)+1, ..., XLS(I+1)-1
C              - LIST OF MAX LENGTH NODES+1
C              - NOT USED
C***********************************************************************
C     .. Scalar Arguments ..
      INTEGER N,NNZ,NODES,ROOT
C     ..
C     .. Array Arguments ..
      INTEGER ICPTR(N+1),IRN(2*NNZ),LS(NODES),MASK(N),XLS(NODES+1)
C     ..
C     .. Local Scalars ..
      INTEGER I,J,JSTOP,JSTRT,LWIDTH,NLVL
C     ..
C     .. External Subroutines ..
      EXTERNAL MC43ID
C     ..
C     .. Executable Statements ..
C
C     GENERATE LEVEL STRUCTURE FOR ROOT NODE
C
      CALL MC43ID(N,NNZ,ROOT,NODES,IRN,ICPTR,MASK,LS,XLS,NLVL,LWIDTH)
C
C     STORE DISTANCES OF EACH NODE FROM ROOT NODE
C
      DO 20 I = 1,NLVL
        JSTRT = XLS(I)
        JSTOP = XLS(I+1) - 1
        DO 10 J = JSTRT,JSTOP
          MASK(LS(J)) = I - 1
   10   CONTINUE
   20 CONTINUE
      RETURN

      END
C***********************************************************************
      SUBROUTINE MC43HD(N,NNZ,NODES,NTOT,NSUP,NSTRT,LSTNUM,NSVAR,NZ,
     +                 SELTVR,SELTPR,IRN,ICPTR,STATUS,NLIST,QUEUE,PRIOR,
     +                 IFRNT,IELIM,IDIST)
C
C
C     RENUMBER NODES IN COMPONENT OF ELEMENT CONNECTIVITY GRAPH FOR
C     SMALL WAVEFRONT PROFILE
C
C N      - NUMBER OF NODES (ELEMENTS) IN GRAPH
C        - UNCHANGED ON EXIT
C NODES  - NUMBER OF NODES (ELEMENTS)IN COMPONENT OF GRAPH
C        - UNCHANGED ON EXIT
C NTOT   - NUMBER OF VARIABLES IN THE PROBLEM
C        - UNCHANGED ON EXIT
C NSUP   - NUMBER OF SUPERVARIABLES IN THE PROBLEM
C        - UNCHANGED ON EXIT
C NSTRT  - NUMBER OF NODE FOR STARTING RENUMBERING
C        - UNCHANGED ON EXIT
C LSTNUM - NUMBER OF NODES WHICH HAVE ALREADY BEEN RENUMBERED
C        - SAME MEANING ON EXIT (INPUT VALUE INCREMENTED BY NODES)
C NSVAR  - INTEGER ARRAY.
C        - CONTAINS THE NUMBER OF VARIABLES IN SUPERVARIABLE I,
C        - I=1,...,NSUP.
C        - UNCHANGED ON EXIT
C  SELTVR - INTEGER ARRAY LENGTH NZ.
C         - CONTAINS ELEMENT SUPERVARIABLE LISTS
C         - UNCHANGED ON EXIT
C  SELTPR - INTEGER ARRAY LENGTH N+1
C         - ELEMENT POINTERS FOR SELTVR
C         - UNCHANGED ON EXIT
C  IRN    - ADJACENCY LIST FOR ALL NODES IN GRAPH
C         - UNCHANGED ON EXIT
C  ICPTR  - LIST OF POINTERS TO IRN
C         - UNCHANGED ON EXIT
C  STATUS - IF NODE 'I' IS IN A COMPONENT WHICH HAS ALREADY BEEN
C           RENUMBERED, THEN THE NEW NODE NUMBER FOR NODE 'I' IS
C           GIVEN BY -STATUS(I)
C         - LIST OF LENGTH N WHERE N IS THE TOTAL NUMBER
C           OF NODES IN THE GRAPH
C  NLIST  - LIST OF NODES WHICH ARE IN THIS COMPONENT
C         - LIST OF LENGTH NODES
C         - UNCHANGED ON EXIT
C  QUEUE  - QUEUE OF NODES WHICH ARE CURRENTLY ACTIVE OR PREACTIVE
C         - LIST OF MAX LENGTH NODES-1
C         - NOT DEFINED WHEN CALLING ROUTINE
C  PRIOR  - LIST OF PRIORITIES FOR EACH NODE
C         - FOR NODE 'I' WHICH IS CURRENTLY IN QUEUE, THE
C           PRIORITY OF NODE 'I' IS GIVEN BY PRIOR(I)
C         - LIST OF LENGTH N, WHERE N IS THE TOTAL NUMBER
C           OF NODES IN THE GRAPH
C         - NOT DEFINED WHEN CALLING ROUTINE
C  IFRNT  - ARRAY OF LENGTH NTOT
C         - NOT SET ON ENTRY
C         - USED TO MONITOR WHEN A VARIABLE ENTERS THE FRONT
C  IELIM  - ARRAY OF LENGTH NTOT
C         - NOT SET ON ENTRY
C         - USED TO MONITOR WHEN A VARIABLE LEAVES THE FRONT
C  IDIST  - LIST GIVING THE DISTANCE OF EACH NODE IN THIS
C           COMPONENT FROM THE END NODE
C         - UNCHANGED ON EXIT
C  NOTE:  - NLIST AND QUEUE MAY OCCUPY SAME SPACE
C***********************************************************************
C
C
C     W1     = A POSITIVE WEIGHT
C     W2     = A POSITIVE WEIGHT
C     W3     = A POSITIVE WEIGHT
C     IDIST   = DISTANCE OF NODE FROM END NODE
C     INITIAL STATUS FOR ALL NODES IN THIS COMPONENT = 2
C
C     .. Parameters ..
      INTEGER W1,W2,W3
      PARAMETER (W1=10,W2=5,W3=1)
C     ..
C     .. Scalar Arguments ..
      INTEGER LSTNUM,N,NNZ,NODES,NSTRT,NSUP,NTOT,NZ
C     ..
C     .. Array Arguments ..
      INTEGER ICPTR(N+1),IDIST(N),IELIM(NSUP),IFRNT(NSUP),IRN(2*NNZ),
     +        NLIST(NODES),NSVAR(NSUP),PRIOR(N),QUEUE(NODES-1),
     +        SELTPR(N+1),SELTVR(NZ),STATUS(N)
C     ..
C     .. Local Scalars ..
      INTEGER ADDRES,I,ISTOP,ISTRT,J,J1,J2,JSTOP,JSTRT,K,LFRNT,MAXPRT,
     +        NABOR,NADJ,NBR,NEXT,NFRNT,NGAIN,NODE,NQ,PRTY
C     ..
C     .. Executable Statements ..
      DO 10 K = 1,NSUP
        IELIM(K) = 0
        IFRNT(K) = 0
   10 CONTINUE
      DO 30 I = 1,NODES
        NODE = NLIST(I)
C  **STORE DISTANCES IN THE ARRAY IDIST
        IDIST(NODE) = STATUS(NODE)
        STATUS(NODE) = 2
C
C    COUNT UP THE NUMBER OF TIMES EACH SUPERVARIABLE APPEARS
C
        J1 = SELTPR(NODE)
        J2 = SELTPR(NODE+1) - 1
        DO 20 J = J1,J2
          K = SELTVR(J)
          IELIM(K) = IELIM(K) + 1
   20   CONTINUE
   30 CONTINUE
C
C     INSERT STARTING NODE IN QUEUE
C     NQ IS THE SIZE OF QUEUE
C
      NQ = 1
      QUEUE(NQ) = NSTRT
      PRIOR(NSTRT) = 1
C
C     LOOP WHILE QUEUE IS NOT EMPTY
C
   40 IF (NQ.GT.0) THEN
C
C       LOOP OVER EACH NODE IN QUEUE
C       PICK NODE WITH MAX PRIORITY
C
        MAXPRT = -W1*NTOT-W3*N
        DO 50 I = 1,NQ
          PRTY = PRIOR(QUEUE(I))
          IF (PRTY.GT.MAXPRT) THEN
            ADDRES = I
            MAXPRT = PRTY
          END IF

   50   CONTINUE
C
C       NEXT IS THE NEXT NODE TO BE RENUMBERED
C
        NEXT = QUEUE(ADDRES)
C
C       DELETE NODE NEXT FROM QUEUE
C
        QUEUE(ADDRES) = QUEUE(NQ)
        NQ = NQ - 1
C
C       STORE -VE OF NEW NODE NUMBER FOR NODE NEXT
C       STATUS FOR NEXT IS NOW -LSTNUM
C
        LSTNUM = LSTNUM + 1
        STATUS(NEXT) = -LSTNUM
C
C  EXAMINE THE VARIABLE LIST FOR NEXT
C
        J1 = SELTPR(NEXT)
        J2 = SELTPR(NEXT+1) - 1
        DO 60 J = J1,J2
          K = SELTVR(J)
          IELIM(K) = IELIM(K) - 1
          IF (IFRNT(K).EQ.0) THEN
            IFRNT(K) = LSTNUM
          END IF

   60   CONTINUE
C
C  EXAMINE THE NEIGHBOURS OF NEXT
C  RECOMPUTE THEIR PRIORITIES AND (IF NOT ALREADY IN QUEUE) ADD
C  TO THE QUEUE
        ISTRT = ICPTR(NEXT)
        ISTOP = ICPTR(NEXT+1) - 1
        DO 90 I = ISTRT,ISTOP
          NBR = IRN(I)
C
          IF (STATUS(NBR).EQ.2 .OR. STATUS(NBR).EQ.1) THEN
C
C  NBR HAS NOT ALREADY BEEN RENUMBERED. RECOMPUTE PRIORITY.
C
            NFRNT = 0
            LFRNT = 0
            J1 = SELTPR(NBR)
            J2 = SELTPR(NBR+1) - 1
            DO 70 J = J1,J2
              K = SELTVR(J)
              IF (IFRNT(K).EQ.0) NFRNT = NFRNT + NSVAR(K)
              IF (IELIM(K).EQ.1) LFRNT = LFRNT + NSVAR(K)
   70       CONTINUE
            NGAIN = NFRNT - LFRNT
C
C  EXAMINE WHICH OF THE NEIGHBOURS OF NBR ARE UNNUMBERED
C
            NADJ = 0
            JSTRT = ICPTR(NBR)
            JSTOP = ICPTR(NBR+1) - 1
            DO 80 J = JSTRT,JSTOP
              NABOR = IRN(J)
              IF (STATUS(NABOR).EQ.1 .OR.
     +            STATUS(NABOR).EQ.2) NADJ = NADJ + 1
   80       CONTINUE
            PRIOR(NBR) = -W1*NGAIN + W2*IDIST(NBR) - W3*NADJ
            IF (STATUS(NBR).EQ.2) THEN
C
C           NBR IS NOT ALREADY IN QUEUE.
C
              NQ = NQ + 1
              QUEUE(NQ) = NBR
              STATUS(NBR) = 1
            END IF

          END IF

   90   CONTINUE
        GO TO 40

      END IF

      RETURN

      END
C***********************************************************************
      SUBROUTINE MC43ID(N,NNZ,ROOT,MAXWID,IRN,ICPTR,MASK,LS,XLS,NLVL,
     +                 LWIDTH)
C
C
C     GENERATE ROOTED LEVEL STRUCTURE USING A FORTRAN 77 IMPLEMENTATION
C     OF THE ALGORITHM GIVEN BY GEORGE AND LUI
C
C     'N'      - NUMBER OF NODES IN GRAPH
C              - UNCHANGED ON EXIT
C     'ROOT'   - ROOT NODE FOR LEVEL STRUCTURE
C              - UNCHANGED ON EXIT
C     'MAXWID' - MAX PERMISSIBLE WIDTH OF ROOTED LEVEL STRUCTURE
C              - ASSEMBLY OF LEVEL STRUCTURE ABORTED IF ANY LEVEL HAS
C                WIDTH WHICH IS GE THIS VALUE
C              - ASSEMBLY ENSURED BY SETTING MAXWID = NODES, WHERE
C                NODES IS THE NUMBER OF NODES IN COMPONENT
C              - UNCHANGED ON EXIT
C     'IRN'    - ADJACENCY LIST FOR ALL NODES IN GRAPH
C              - UNCHANGED ON EXIT
C     'ICPTR'  - LIST OF POINTERS TO IRN
C                NUMBER OF NODES IN THE GRAPH
C              - UNCHANGED ON EXIT
C     'MASK'   - MASKING VECTOR FOR GRAPH
C              - VISIBLE NODES HAVE MASK = 1
C              - LIST OF LENGTH N, WHERE N IS THE TOTAL
C                NUMBER OF NODES IN THE GRAPH
C              - UNCHANGED ON EXIT
C     'LS'     - NOT SET
C              - ON EXIT LIST CONTAINING A ROOTED LEVEL STRUCTURE
C     'XLS'    - NOT SET
C              - ON EXIT LIST OF POINTERS TO LS
C              - NODES IN LEVEL 'I' ARE FOUND IN LS(J), WHERE
C                J = XLS(I), XLS(I)+1, ..., XLS(I+1)-1
C              - LIST OF MAX LENGTH N+1
C     'NLVL'   - NOT SET
C              - ON EXIT NUMBER OF LEVELS IN ROOTED LEVEL STRUCTURE
C     'LWIDTH' - NOT SET
C              - ON EXIT WIDTH OF ROOTED LEVEL STRUCTURE
C***********************************************************************
C
C     .. Scalar Arguments ..
      INTEGER LWIDTH,MAXWID,N,NLVL,NNZ,ROOT
C     ..
C     .. Array Arguments ..
      INTEGER ICPTR(N+1),IRN(2*NNZ),LS(N),MASK(N),XLS(N+1)
C     ..
C     .. Local Scalars ..
      INTEGER I,J,JSTOP,JSTRT,LBEGIN,LNBR,LVLEND,LVSIZE,NBR,NODE
C     ..
C     .. Intrinsic Functions ..
      INTRINSIC MAX
C     ..
C     .. Executable Statements ..
C     INITIALISATION
C
      MASK(ROOT) = 0
      LS(1) = ROOT
      NLVL = 0
      LVLEND = 0
      LNBR = 1
      LWIDTH = 1
      LVSIZE = 1
   10 IF (LVSIZE.GT.0) THEN
        LWIDTH = MAX(LVSIZE,LWIDTH)
C
C       ABORT CONSTRUCTION IF LEVEL STRUCTURE HAS WIDTH GE 'MAXWID'
C
        IF (LWIDTH.GE.MAXWID) THEN
          GO TO 40

        END IF
C
C       LBEGIN POINTS TO BEGINNING OF PRESENT LEVEL
C       LVLEND POINTS TO END OF PRESENT LEVEL
C
        LBEGIN = LVLEND + 1
        LVLEND = LNBR
        NLVL = NLVL + 1
        XLS(NLVL) = LBEGIN
C
C       GENERATE NEXT LEVEL BY FINDING ALL UNMASKED NEIGHBOURS
C       OF NODES IN PRESENT LEVEL
C
        DO 30 I = LBEGIN,LVLEND
          NODE = LS(I)
          JSTRT = ICPTR(NODE)
          JSTOP = ICPTR(NODE+1) - 1
          DO 20 J = JSTRT,JSTOP
            NBR = IRN(J)
            IF (MASK(NBR).EQ.1) THEN
              LNBR = LNBR + 1
              LS(LNBR) = NBR
              MASK(NBR) = 0
            END IF

   20     CONTINUE
   30   CONTINUE
        LVSIZE = LNBR - LVLEND
        GO TO 10

      END IF

      XLS(NLVL+1) = LVLEND + 1
C
C     RESET MASK=1 FOR NODES IN THE LEVEL STRUCTURE
C
   40 CONTINUE
      DO 50 I = 1,LNBR
        MASK(LS(I)) = 1
   50 CONTINUE
      RETURN

      END
C***********************************************************************
      SUBROUTINE MC43JD(N,NL,LIST,KEY)
C
C
C     ORDER A LIST OF INTEGERS IN ASCENDING SEQUENCE OF THEIR KEYS
C
C     'NL'   - POSITIVE INTEGER GIVING LENGTH OF LIST
C            - UNCHANGED ON EXIT
C     'N'    - POSITIVE INTEGER GIVING LENGTH OF KEY
C            - UNCHANGED ON EXIT
C     'LIST' - A LIST OF LENGTH NL OF INTEGERS
C            - ON EXIT A LIST OF LENGTH NL OF INTEGERS SORTED IN
C              ASCENDING SEQUENCE OF THEIR INTEGER KEYS
C     'KEY'  - A LIST OF N OF INTEGER KEYS
C            - UNCHANGED ON EXIT
C
C NOTE: - USES INSERTION SORT
C       - EFFICIENT ONLY FOR N VALUES LESS THAN ABOUT 12 (ALTHOUGH
C         MAY BE SYSTEM DEPENDENT) AS DISCUSSED IN HOULSBY AND SLOAN
C***********************************************************************
C     .. Scalar Arguments ..
      INTEGER N,NL
C     ..
C     .. Array Arguments ..
      INTEGER KEY(N),LIST(NL)
C     ..
C     .. Local Scalars ..
      INTEGER I,J,K,VALUE
C     ..
C     .. Executable Statements ..
C
C     FIND INTEGER WITH SMALLEST KEY AND PUT IT AT HEAD OF LIST
      J = 1
      K = LIST(1)
      VALUE = KEY(K)
      DO 10 I = 2,NL
        IF (KEY(LIST(I)).LT.VALUE) THEN
          J = I
          VALUE = KEY(LIST(I))
        END IF

   10 CONTINUE
      LIST(1) = LIST(J)
      LIST(J) = K
C
C     CARRY OUT INSERTION SORT
C
      DO 30 I = 2,NL
        J = I
        K = LIST(I)
        VALUE = KEY(K)
   20   IF (VALUE.LT.KEY(LIST(J-1))) THEN
          LIST(J) = LIST(J-1)
          J = J - 1
          GO TO 20

        END IF

        LIST(J) = K
   30 CONTINUE
      RETURN

      END
C*********************************************************************
      SUBROUTINE MC43KD(N,NELT,NZ,ELTVAR,ELTPTR,NSUP,VAR,NSVAR,SELTVR,
     +                 SELTPR,ELEMP)
C
C   GIVEN THE STRUCTURE OF AN UNASSEMBLED FINITE ELEMENT MATRIX,
C   GROUP THE VARIABLES INTO SUPERVARIABLES
C   (EACH VARIABLE IN A SUPERVARIABLE BELONGS TO THE SAME SET OF
C   ELEMENTS).
C
C*********************************************************************
C N     - INTEGER VARIABLE
C       - MUST BE SET TO THE LARGEST INTEGER USED TO INDEX A VARIABLE.
C       - THIS ARGUMENT IS NOT CHANGED.
C NELT - INTEGER VARIABLE
C      - MUST BE SET TO THE NUMBER OF ELEMENTS AND IS NOT CHANGED
C NZ    - INTEGER VARIABLE
C       - MUST BE SET TO THE ELTPTR(NELT+1)-1 AND IS NOT CHANGED
C ELTVAR - INTEGER ARRAY. ON ENTRY, MUST BE SET TO LISTS OF
C        - VARIABLES IN ELEMENTS. THOSE FOR ELEMENT 1 PRECEDE THOSE FOR
C        - ELEMENT 2 AND SO ON.  UNCHANGED ON EXIT
C ELTPTR - INTEGER ARRAY.  ON ENTRY, ELTPTR(J) MUST CONTAIN THE
C        - POSITION IN ELTVAR OF THE FIRST VARIABLE IN ELEMENT J
C        - (J=1,...,NELT) AND ELTADJ(NELT+1) MUST BE SET TO THE POSITION
C        - AFTER THE LAST VARIABLE OF THE LAST ELEMENT.  UNCHANGED ON
C        - EXIT.
C NSUP   - INTEGER VARIABLE. NEED NOT BE SET ON ENTRY. ON RETURN, HOLDS
C        - THE NUMBER OF SUPERVARIABLES.
C VAR    - INTEGER ARRAY. NEED NOT BE SET ON ENTRY. ON RETURN, VAR(I)
C        - CONTAINS THE SUPERVARIABLE TO WHICH VARIABLE BELONGS,
C        - I=1,...,N.
C NSVAR  - INTEGER ARRAY. NEED NOT BE SET ON ENTRY. ON RETURN, NSVAR(I)
C        - CONTAINS THE NUMBER OF VARIABLES IN SUPERVARIABLE I,
C        - I=1,...,NSUP.
C SELTVR - INTEGER ARRAY. NOT SET ON ENTRY.
C        - ON EXIT CONTAINS ELEMENT SUPERVARIABLE LISTS
C          WITH THE SUPERVARIABLES FOR ELEMENT 1 PRECEDING
C          THOSE FOR ELEMENT 2, AND SO ON.
C SELTPR - INTEGER ARRAY OF LENGTH NELT+1
C        - NOT SET ON ENTRY
C        - ON EXIT SELTPR(I) CONTAINS THE POSITION IN SELTVR
C          OF THE FIRST SUPERVARIABLE IN ELEMENT I (I=1,...,NELT)
C          AND SELTPR(NELT+1) IS SET TO THE POSITION IN SELTVR
C          AFTER THE LAST SUPERVARIABLE IN THE LAST ELEMENT.
C ELEMP  - INTEGER ARRAY OF LENGTH NZ. USED FOR WORKSPACE.
C********************************************************************
C
C
C  INITIALIZE VAR
C     .. Scalar Arguments ..
      INTEGER N,NELT,NSUP,NZ
C     ..
C     .. Array Arguments ..
      INTEGER ELEMP(NZ),ELTPTR(NELT+1),ELTVAR(NZ),NSVAR(NZ),
     +        SELTPR(NELT+1),SELTVR(NZ),VAR(N)
C     ..
C     .. Local Scalars ..
      INTEGER END,I,IE,IELT,ISUP,J,J1,J2,K,L,M,START
C     ..
C     .. Executable Statements ..
      DO 10 I = 1,N
        VAR(I) = 0
   10 CONTINUE
C
C IN THIS LOOP, SUPERVARIABLE K TOUCHES ELEMENTS NSVAR(K),
C NSVAR(ELEMP(K)), NSVAR(ELEMP(ELEMP(K))),...; THE SUPERVARIABLES
C FOR THE CURRENT ELEMENT RUN FROM START TO END.
      END = 0
      DO 50 IE = NELT,1,-1
        START = END + 1
        DO 40 I = ELTPTR(IE),ELTPTR(IE+1) - 1
          M = ELTVAR(I)
          K = VAR(M)
C  JUMP IF WE ALREADY HAVE THE SUPERVARIABLE
          DO 20 L = START,END
            IF (ELEMP(L).EQ.K) GO TO 30
   20     CONTINUE
C CREATE NEW SUPERVARIABLE
          END = END + 1
          NSVAR(END) = IE
          ELEMP(END) = K
          L = END
C STORE VARIABLE TO SUPERVARIABLE POINTER
   30     VAR(M) = L
   40   CONTINUE
   50 CONTINUE
C
C CONSTRUCT SUPERVARIABLES
      NSUP = 0
      DO 70 M = 1,N
        L = VAR(M)
        IF (L.EQ.0) GO TO 70
        ISUP = -ELEMP(L)
        IF (ISUP.GT.0) GO TO 60
C WE HAVE A NEW SUPERVARIABLE
        NSUP = NSUP + 1
        NSVAR(NSUP) = 1
        VAR(M) = NSUP
        ELEMP(L) = -NSUP
        GO TO 70
C WE HAVE AN OLD SUPERVARIABLE
   60   NSVAR(ISUP) = NSVAR(ISUP) + 1
        VAR(M) = ISUP
   70 CONTINUE
C
C  SET UP ELEMENT SUPERVARIABLE LISTS
C
      DO 80 I = 1,NSUP
        ELEMP(I) = 0
   80 CONTINUE
      END = 0
      SELTPR(1) = 1
      DO 100 IELT = 1,NELT
        J1 = ELTPTR(IELT)
        J2 = ELTPTR(IELT+1) - 1
        SELTPR(IELT+1) = SELTPR(IELT)
        DO 90 J = J1,J2
          K = ELTVAR(J)
          K = VAR(K)
          IF (ELEMP(K).LT.IELT) THEN
            ELEMP(K) = IELT
            END = END + 1
            SELTVR(END) = K
            SELTPR(IELT+1) = SELTPR(IELT+1) + 1
          END IF

   90   CONTINUE
  100 CONTINUE
      RETURN

      END
C**********************************************************
C
      SUBROUTINE MC43LD(NSUP,NELT,NNZ,SELTVR,SELTPR,ICP,IRN,LENIRN,IW,
     +                 IFLAG)
C
C
C PURPOSE: SETS UP THE ARRYS IRN AND ICP FOR THE STRICT LOWER TRIANGLE
C          OF THE MATRIX CORRESPONDING TO THE SUPERVARIABLE
C          CONNECTIVITY GRAPH
C NSUP   - INTEGER. NUMBER OF COLUMNS IN THE ASSEMBLED MATRIX.
C          (= NUMBER OF SUPERVARIABLES)
C        - UNCHANGED ON EXIT
C NELT   - INTEGER. TOTAL NUMBER OF ELEMENTS.
C        - UNCHANGED ON EXIT
C NNZ    - INTEGER. ON EXIT NNZ IS THE NUMBER OF ENTRIES IN THE
C          STRICT LOWER TRIANGLE OF THE MATRIX.
C SELTVR - INTEGER ARRAY. CONTAINS ELEMENT SUPERVARIABLE LISTS.
C        - UNCHANGED ON EXIT
C SELTPR - INTEGER ARRAY OF LENGTH NELT+1. CONTAINS POINTERS FOR
C          SELTVR.
C        - UNCHANGED ON EXIT.
C ICP    - INTEGER ARRAY OF LENGTH NSUP+1. NOT SET ON ENTRY.
C IRN    - INTEGER ARRAY OF LENGTH LENIRN. NOT SET ON ENTRY.
C LENIRN - INTEGER. LENGTH OF ARRAY IRN.
C        - UNCHANGED ON EXIT
C IW     - INTEGER ARRAY OF LENGTH NSUP. USED AS WORKSPACE.
C IFLAG  - INTEGER.  USED FOR ERROR RETURNS.
C        - IF ON ENTRY IFLAG=-5 THE USER HAS SUPPLIED THE MAIN
C          PROGRAM WITH INSUFFICIENT WORKSPACE AND THIS
C          ROUTINE THEN JUST ATTEMPTS TO FIND THE REQUIRED
C          AMOUNT OF SPACE.
C***********************************************************
C
C     .. Scalar Arguments ..
      INTEGER IFLAG,LENIRN,NELT,NNZ,NSUP
C     ..
C     .. Array Arguments ..
      INTEGER ICP(NSUP+1),IRN(LENIRN),IW(NSUP),SELTPR(NELT+1),SELTVR(*)
C     ..
C     .. Local Scalars ..
      INTEGER I,IA,IB,IELT,II,J,J1,J2,JJ,JSTOP,JSTRT,JSUB,JVAR,K,K2,L
C     ..
C     .. Common blocks ..
      COMMON /MC43TD/LP,IWUSE(2)
      INTEGER LP
      INTEGER IWUSE
C     ..
C     .. Save statement ..
      SAVE /MC43TD/
C     ..
C     .. Executable Statements ..
      DO 10 J = 1,NSUP
        IW(J) = 0
   10 CONTINUE
C      DO 20 J = 1,LENIRN
C        IRN(J) = 0
C   20 CONTINUE
      DO 30 I = 1,NSUP + 1
        ICP(I) = 0
   30 CONTINUE
      DO 60 IELT = 1,NELT
        JSTRT = SELTPR(IELT)
        JSTOP = SELTPR(IELT+1) - 1
        DO 50 I = JSTRT,JSTOP
          JVAR = SELTVR(I)
          DO 40 II = JSTRT,JSTOP
            JJ = SELTVR(II)
            IF (JJ.GT.JVAR) ICP(JVAR+1) = ICP(JVAR+1) + 1
   40     CONTINUE
   50   CONTINUE
   60 CONTINUE
C
C  SET ICP SO THAT ICP(I) POINTS TO THE FIRST ENTRY IN COLUMN I
C  (I=1,...,NSUP) AND ICP(NSUP+1) IS SET TO THE NUMBER OF ENTRIES+1.
      ICP(1) = 1
      DO 70 J = 2,NSUP + 1
        ICP(J) = ICP(J) + ICP(J-1)
   70 CONTINUE
C
      DO 100 IELT = 1,NELT
        JSTRT = SELTPR(IELT)
        JSTOP = SELTPR(IELT+1) - 1
        DO 90 K = JSTRT,JSTOP
          J = SELTVR(K)
          JSUB = ICP(J)
          DO 80 K2 = JSTRT,JSTOP
            J2 = SELTVR(K2)
            IF (J2.LE.J) GO TO 80
            IF (JSUB.GT.LENIRN) IFLAG = -5
            IF (JSUB.LE.LENIRN) IRN(JSUB) = J2
            JSUB = JSUB + 1
   80     CONTINUE
          ICP(J) = JSUB
   90   CONTINUE
  100 CONTINUE
      IF (IFLAG.EQ.-5 .AND. JSUB.GT.LENIRN) THEN
        IWUSE(1) = JSUB
        RETURN

      END IF
C  RESET ICP
      IA = 1
      DO 110 J = 1,NSUP
        IB = ICP(J)
        ICP(J) = IA
        IA = IB
  110 CONTINUE
C ELIMINATE DUPLICATES
      L = 0
      J1 = ICP(1)
      DO 130 K = 1,NSUP
        J2 = ICP(K+1)
        ICP(K+1) = ICP(K)
        DO 120 J = J1,J2 - 1
          I = IRN(J)
          IF (IW(I).LT.K) THEN
            IW(I) = K
            L = L + 1
            IRN(L) = I
            ICP(K+1) = ICP(K+1) + 1
          END IF

  120   CONTINUE
        J1 = J2
  130 CONTINUE
      NNZ = L
      IF (2*NNZ.GT.LENIRN) IFLAG = -5
      IF (IFLAG.EQ.-5) THEN
        IWUSE(1) = 2*NNZ
        RETURN

      END IF

      RETURN

      END
C*******************************************************************
      SUBROUTINE MC43MD(N,NNZ,NTOT,IRN,ICPTR,NSVAR,IPERM,IW)
C
C
C     ALGORITHM TO REDUCE THE PROFILE OF A SPARSE SQUARE MATRIX WITH A
C     SYMMETRIC SPARSITY PATTERN.
C     THE USER MUST SUPPLY THE PATTERN OF THE ENTRIES IN THE STRICTLY
C     LOWER TRIANGULAR PART OF THE MATRIX.
C
C  N   - ORDER OF THE MATRIX= NUMBER OF SUPERVARIABLES
C      - UNCHANGED ON EXIT
C NTOT - TOTAL NUMBER OF VARIABLES IN THE PROBLEM
C      - UNCHANGED ON EXIT
C NNZ  - ON ENTRY, NNZ IS THE NUMBER OF ENTRIES IN THE STRICT
C        LOWER TRIANGLE OF THE MATRIX
C        = NUMBER OF EDGES IN SUPERVARIABLE CONNECTIVITY GRAPH.
C      - UNCHANGED ON EXIT
C IRN  - INTEGER ARRAY OF LENGTH 2*NNZ
C      - IRN CONTAINS THE ROW INDICES OF THE
C        ENTRIES IN THE STRICT LOWER TRIANGLE OF THE MATRIX
C      - ON EXIT CONTAINS ROW INDICES FOR EXPANDED MATRIX
C ICPTR- INTEGER ARRAY OF LENGTH N+1
C      - ICPTR IS SET SO THAT ICPTR(J) IS THE
C        POSITION IN THE ARRAY IRN OF THE FIRST ENTRY IN
C        COLUMN J (J=1,...,N)
C      - THE ARRAY HAS THE SAME MEANING ON EXIT
C NSVAR- INTEGER ARRAY OF LENGTH N
C      - NSVAR(I) CONTAINS THE NUMBER OF VARIABLES IN SUPERVARIABLE
C        I (I=1,...,N)
C      - UNCHANGED ON EXIT
C IPERM- INTEGER ARRAY OF LENGTH N
C      - THIS ARRAY IS NOT SET ON ENTRY
C      - ON EXIT CONTAINS THE NEW NODE NUMBERS
C IW   - INTEGER ARRAY DEFINING WORKSPACE FOR RENUMBERING
C      - LENGTH OF ARRAY 3*N+2
C***********************************************************************
C
C     .. Scalar Arguments ..
      INTEGER N,NNZ,NTOT
C     ..
C     .. Array Arguments ..
      INTEGER ICPTR(N+1),IPERM(N),IRN(2*NNZ),IW(3*N+2),NSVAR(N)
C     ..
C     .. Local Scalars ..
      INTEGER DEGREE,I,J,K,LSTNUM,N1,N2,N3,NODES,NSTOP,NSTRT
      LOGICAL YESA
C     ..
C     .. Local Arrays ..
      DOUBLE PRECISION A(1)
C     ..
C     .. External Subroutines ..
      EXTERNAL MC34AD,MC43GD,MC43PD,MC43QD,MC43RD
C     ..
C     .. Executable Statements ..
      YESA = .FALSE.
      DO 10 I = 1,3*N + 2
        IW(I) = 0
   10 CONTINUE
C
C  EXPAND MATRIX STRUCTURE
C
      CALL MC34AD(N,IRN,ICPTR,YESA,A,IW)
C      DO 20 I = 1,N
C        IW(I) = 0
C   20 CONTINUE
C
C ***THE RENUMBERING ALGORITHM ***
C     SET ALL NEW NODE NUMBERS = 1
C     THIS IS USED TO DENOTE ALL VISIBLE NODES
C
      DO 30 I = 1,N
        IPERM(I) = 1
   30 CONTINUE
C
C     SET LAST NEW NODE NUMBER
C
      LSTNUM = 0
C
C     RENUMBER ALL NODES OF DEGREE ZERO
C     STORE -VE OF NEW NODE NUMBER
C
      DO 50 I = 1,N
        DEGREE = 0
        DO 40 J = ICPTR(I),ICPTR(I+1) - 1
          K = IRN(J)
          DEGREE = DEGREE + NSVAR(K)
   40   CONTINUE
        IF (DEGREE.EQ.0) THEN
          LSTNUM = LSTNUM + 1
          IPERM(I) = -LSTNUM
        END IF

   50 CONTINUE
C
C     LOOP WHILE SOME NODES REMAIN UNNUMBERED
C
   60 IF (LSTNUM.LT.N) THEN
C
C       FIND END POINTS OF P-DIAMETER FOR NODES IN THIS COMPONENT
C
        N1 = 1
        N2 = N1 + N - LSTNUM
        N3 = N2 + N + 1
        CALL MC43PD(N,NNZ,NTOT,IRN,ICPTR,NSVAR,IPERM,IW(N1),IW(N2),
     +             IW(N2),IW(N3),NSTRT,NSTOP,NODES)
C
C       COMPUTE DISTANCES FROM END NODE AND ASSEMBLE LIST OF NODES
C       THAT ARE IN THIS COMPONENT
C
        N2 = N1 + NODES
        N3 = N2 + NODES + 1
        CALL MC43GD(N,NNZ,NSTOP,NODES,IRN,ICPTR,IPERM,IW(N1),IW(N2))
C
C       RENUMBER NODES IN THIS COMPONENT
C
        N3 = N2 + N
        CALL MC43QD(N,NNZ,NTOT,NODES,NSTRT,LSTNUM,IRN,ICPTR,NSVAR,IPERM,
     +             IW(N1),IW(N1),IW(N2))
        GO TO 60

      END IF
C
C     SET NEW NODE NUMBERS TO +VE VALUES
C
      DO 70 I = 1,N
        IPERM(I) = -IPERM(I)
   70 CONTINUE
C
C     COMPUTE PROFILES FOR OLD AND NEW NODE NUMBERS
C
      CALL MC43RD(N,NNZ,IPERM,IRN,ICPTR,IW(1))
C
C     USE ORIGINAL NUMBERING IF NEW NUMBERING GIVES GREATER PROFILE
C
      IF (IW(2).GE.IW(1)) THEN
        DO 80 I = 1,N
          IPERM(I) = I
   80   CONTINUE
      END IF

      RETURN

      END
C********************************************************************
      SUBROUTINE MC43ND(NSUP,NELT,NZ,SELTVR,SELTPR,IPERM,KEY,LIST)
C
C
C   THE ROUTINE FINDS THE HIGHEST NUMBERED SUPERVARIABLE IN EACH
C   ELEMENT. THE REORDERED SUPERVARIABLE NUMBERS ARE USED.
C
C   NSUP - TOTALNUMBER OF SUPERVARIABLES
C        - UNCHANGED ON EXIT
C   NELT - TOTAL NUMBER OF ELEMENTS
C        - UNCHANGED ON EXIT
C SELTVR - INTEGER ARRAY. CONTAINS ELEMENT SUPERVARIABLE LISTS.
C        - UNCHANGED ON EXIT
C SELTPR - INTEGER ARRAY OF LENGTH NELT+1. CONTAINS POINTERS FOR
C          SELTVR.
C       - UNCHANGED ON EXIT.
C IPERM - INTEGER ARRAY OF LENGTH NSUP
C       - UNCHANGED ON EXIT
C   KEY - INTEGER ARRAY OF LENGTH NELT
C       - NOT SET ON ENTRY
C       - ON EXIT CONTAINS THE HIGHEST NUMBERED
C         SUPERVARIABLE IN EACH ELEMENT
C  LIST - INTEGER ARRAY OF LENGTH NELT
C       - NOT SET ON ENTRY
C       - ON EXIT CONTAINS A LIST OF THE ELEMENT NUMBERS
C***********************************************************
C
C     .. Scalar Arguments ..
      INTEGER NELT,NSUP,NZ
C     ..
C     .. Array Arguments ..
      INTEGER IPERM(NSUP),KEY(NELT),LIST(NELT),SELTPR(NELT+1),SELTVR(NZ)
C     ..
C     .. Local Scalars ..
      INTEGER I,IELL,J,JSTOP,JSTRT,L
C     ..
C     .. Executable Statements ..
      DO 10 I = 1,NELT
        LIST(I) = 0
        KEY(I) = 0
   10 CONTINUE
C
C  SET UP LIST AND KEY (USING THE NEW SUPERVARIABLE NUMBERS)
C  KEY(I) IS TO BE THE LOWEST NUMBERED SUPERVARIABLE IN ELEMENT I.
C
      DO 30 IELL = 1,NELT
        LIST(IELL) = IELL
        JSTRT = SELTPR(IELL)
        JSTOP = SELTPR(IELL+1) - 1
        J = SELTVR(JSTRT)
        KEY(IELL) = IPERM(J)
        DO 20 I = JSTRT + 1,JSTOP
          J = SELTVR(I)
          L = IPERM(J)
          IF (L.LT.KEY(IELL)) KEY(IELL) = L
   20   CONTINUE
   30 CONTINUE
      RETURN

      END
C***********************************************************
      SUBROUTINE MC43OD(N,LIST,KEY,IW)
C
C
C PURPOSE: ORDER A LIST OF INTEGERS IN ASCENDING SEQUENCE OF THEIR KEYS
C     N    - POSITIVE INTEGER GIVING LENGTH OF LIST
C          - UNCHANGED ON EXIT
C     LIST - A LIST OF LENGTH N OF INTEGERS
C          - ON EXIT THE INTEGERS ARE SORTED IN ASCENDING SEQUENCE
C            OF THEIR INTEGER KEYS.
C     KEY  - AN INTEGER LIST OF LENGTH AT LEAST N OF INTEGER KEYS
C          - UNCHANGED ON EXIT
C NOTE: - USES QUICK SORT
C       - CODE BY G HOULSBY AND S W SLOAN.
C***********************************************************************
C
C     .. Scalar Arguments ..
      INTEGER N
C     ..
C     .. Array Arguments ..
      INTEGER IW(64),KEY(N),LIST(N)
C     ..
C     .. Local Scalars ..
      INTEGER GUESS,I,LL,LM,LR,LTEMP,NL,NR,STKTOP
C     ..
C     .. Executable Statements ..
      DO 10 I = 1,64
        IW(64) = 0
   10 CONTINUE
      LL = 1
      LR = N
      STKTOP = 0
   20 CONTINUE
      IF (LL.LT.LR) THEN
        NL = LL
        NR = LR
        LM = (LL+LR)/2
        GUESS = KEY(LIST(LM))
C
C FIND KEYS FOR EXCHANGE
C
   30   CONTINUE
        IF (KEY(LIST(NL)).LT.GUESS) THEN
          NL = NL + 1
          GO TO 30

        END IF

   40   CONTINUE
        IF (GUESS.LT.KEY(LIST(NR))) THEN
          NR = NR - 1
          GO TO 40

        END IF

        IF (NL.LT. (NR-1)) THEN
          LTEMP = LIST(NL)
          LIST(NL) = LIST(NR)
          LIST(NR) = LTEMP
          NL = NL + 1
          NR = NR - 1
          GO TO 30

        END IF
C
C  DEAL WITH CROSSING OF POINTERS
C
        IF (NL.LE.NR) THEN
          IF (NL.LT.NR) THEN
            LTEMP = LIST(NL)
            LIST(NL) = LIST(NR)
            LIST(NR) = LTEMP
          END IF

          NL = NL + 1
          NR = NR - 1
        END IF
C
C  SELECT SUB-LIST TO BE PROCESSED NEXT
C
        STKTOP = STKTOP + 1
        IF (NR.LT.LM) THEN
          IW(STKTOP) = NL
          IW(32+STKTOP) = LR
          LR = NR

        ELSE
          IW(STKTOP) = LL
          IW(32+STKTOP) = NR
          LL = NL
        END IF

        GO TO 20

      END IF
C
C PROCESS ANY STACKED SUB-LISTS
C
      IF (STKTOP.NE.0) THEN
        LL = IW(STKTOP)
        LR = IW(32+STKTOP)
        STKTOP = STKTOP - 1
        GO TO 20

      END IF

      RETURN

      END
C****************************************************************
      SUBROUTINE MC43PD(N,NNZ,NTOT,IRN,ICPTR,NSVAR,MASK,LS,XLS,DEG,LIST,
     +                 NSTRT,NSTOP,NODES)
C
C
C     FIND NODES WHICH DEFINE A PSUEDO-DIAMETER OF A GRAPH
C
C  N    - TOTAL NUMBER OF NODES IN GRAPH = NUMBER OF SUPERVARIABLES
C       - UNCHANGED ON EXIT
C NTOT  - TOTAL NUMBER OF VARIABLES IN THE PROBLEM (NTOT>N)
C       - UNCHANGED ON EXIT
C IRN   - ADJACENCY LIST FOR ALL NODES IN GRAPH
C       - UNCHANGED ON EXIT
C ICPTR - LIST OF POINTERS TO IRN
C       - NODES ADJACENT TO NODE 'I' ARE FOUND IN IRN(J), WHERE
C         J = ICPTR(I), ICPTR(I)+1, ..., ICPTR(I+1)-1
C       - UNCHANGED ON EXIT
C NSVAR - INTEGER ARRAY OF LENGTH N.
C       - NSVAR(I) CONTAINS THE NUMBER OF VARIABLES IN SUPERVARIABLE
C         I (I=1,...,N)
C       - UNCHANGED ON EXIT
C MASK  - MASKING VECTOR FOR GRAPH
C       - VISIBLE NODES HAVE MASK = 1
C       - NODE IS INVISIBLE OTHERWISE
C       - LIST OF LENGTH N
C LS    - LIST CONTAINING A ROOTED LEVEL STRUCTURE
C       - LIST OF MAX LENGTH N
C          - NOT DEFINED WHEN CALLING ROUTINE
C XLS   - LIST OF POINTERS TO LS
C       - NODES IN LEVEL 'I' ARE FOUND IN LS(J), WHERE
C         J = XLS(I), XLS(I)+1, ..., XLS(I+1)-1
C       - THE WIDTH OF LEVEL 'I' IS GIVEN BY XLS(I+1)-XLS(I)
C       - LIST OF  LENGTH N+1
C       - NOT DEFINED WHEN CALLING ROUTINE
C DEG   - LIST OF DEGREES OF NODES ON BOTTOM LEVEL OF ROOTED
C         STRUCTURE
C       - LIST OF  LENGTH N
C       - NOT DEFINED WHEN CALLING ROUTINE
C LIST  - LIST OF NODES ON BOTTOM LEVEL OF ROOTED LEVEL STRUCTURE
C       - LIST OF MAX LENGTH N
C       - NOT DEFINED WHEN CALLING ROUTINE
C NSTRT - NOT SET ON ENTRY
C       - ON EXIT STARTING NODE FOR RENUMBERING
C NSTOP - NOT SET ON ENTRY
C       - ON EXIT END NODE FOR RENUMBERING
C NODES - NOT SET ON ENTRY
C       - ON EXIT THE NUMBER OF NODES IN THIS COMPONENT OF GRAPH
C NOTE: - DEG AND XLS MAY OCCUPY SAME SPACE
C       - NSTRT AND NSTOP DEFINE A PSUEDO-DIAMETER OF THIS COMPONENT
C         OF THE GRAPH
C***********************************************************************
C
C     CHOOSE FIRST GUESS FOR STARTING NODE BY MIN DEGREE
C     IGNORE NODES THAT ARE INVISIBLE (MASK NE 1)
C
C     .. Scalar Arguments ..
      INTEGER N,NNZ,NODES,NSTOP,NSTRT,NTOT
C     ..
C     .. Array Arguments ..
      INTEGER DEG(N),ICPTR(N+1),IRN(2*NNZ),LIST(N),LS(N),MASK(N),
     +        NSVAR(N),XLS(N+1)
C     ..
C     .. Local Scalars ..
      INTEGER DEGREE,I,ID1,ID2,ISTOP,ISTRT,J,K,LSIZE,LWIDTH,MAXDEP,
     +        MINDEG,MINWID,NLSIZE,NLVL,NODE
C     ..
C     .. External Subroutines ..
      EXTERNAL MC43ID,MC43JD
C     ..
C     .. Executable Statements ..
c      MINDEG = N*NTOT
      MINDEG = 0
      DO 20 I = 1,N
        IF (MASK(I).EQ.1) THEN
          DEGREE = 0
          DO 10 J = ICPTR(I),ICPTR(I+1) - 1
            K = IRN(J)
            DEGREE = DEGREE + NSVAR(K)
   10     CONTINUE
          IF (DEGREE.LT.MINDEG.OR. MINDEG.EQ.0) THEN
            NSTRT = I
            MINDEG = DEGREE
          END IF

        END IF

   20 CONTINUE
C
C     GENERATE LEVEL STRUCTURE FOR NODE WITH MIN DEGREE
C
      CALL MC43ID(N,NNZ,NSTRT,N,IRN,ICPTR,MASK,LS,XLS,MAXDEP,LWIDTH)
C
C     STORE NUMBER OF NODES IN THIS COMPONENT
C
      NODES = XLS(MAXDEP+1) - 1
C
C     ITERATE TO FIND START AND END NODES
C
   30 CONTINUE
C
C     STORE DEGREES OF NODES THAT ARE AT MAX DISTANCE FROM STARTING NODE
C
      ISTRT = XLS(MAXDEP)
      ISTOP = XLS(MAXDEP+1) - 1
      DO 50 I = ISTRT,ISTOP
        NODE = LS(I)
        DEG(NODE) = 0
        DO 40 J = ICPTR(NODE),ICPTR(NODE+1) - 1
          K = IRN(J)
          DEG(NODE) = DEG(NODE) + NSVAR(K)
   40   CONTINUE
   50 CONTINUE
C
C     SORT LIST OF NODES IN ASCENDING SEQUENCE OF THEIR DEGREE
C     USE INSERTION SORT ALGORITHM (HOULSBY AND SLOAN)
C
      LSIZE = ISTOP - ISTRT + 1
      IF (LSIZE.GT.1) CALL MC43JD(N,LSIZE,LS(ISTRT),DEG)
C
C     STORE THE SORTED LIST
C
      ISTRT = ISTRT - 1
      DO 60 I = 1,LSIZE
        LIST(I) = LS(ISTRT+I)
   60 CONTINUE
      ID1 = DEG(LIST(1))
      NLSIZE = 1
      DO 70 I = 2,LSIZE
        ID2 = DEG(LIST(I))
        IF (ID2.NE.ID1) THEN
          NLSIZE = NLSIZE + 1
          LIST(NLSIZE) = LIST(I)
        END IF

        ID1 = ID2
   70 CONTINUE
C
C     LOOP OVER NODES IN LIST
C
      MINWID = NODES
      DO 80 I = 1,NLSIZE
        NODE = LIST(I)
C
C       FORM ROOTED LEVEL STRUCTURES FOR EACH NODE IN LIST
C
        CALL MC43ID(N,NNZ,NODE,MINWID,IRN,ICPTR,MASK,LS,XLS,NLVL,LWIDTH)
        IF ((NLVL.GT.MAXDEP) .AND. (LWIDTH.LT.MINWID)) THEN
C
C           LEVEL STRUCTURE OF GREATER DEPTH FOUND
C           STORE ROOT NODE AS STARTING NODE, NEW MAX DEPTH, AND BEGIN
C           A NEW ITERATION
C
          NSTRT = NODE
          MAXDEP = NLVL
          GO TO 30

        ELSE IF (LWIDTH.LT.MINWID) THEN
C
C             LEVEL STRUCTURE WIDTH FOR THIS END NODE IS SMALLEST
C             ENCOUNTERED SO FAR
C             STORE END NODE AND NEW MIN WIDTH
C
          NSTOP = NODE
          MINWID = LWIDTH
        END IF

   80 CONTINUE
C
      RETURN

      END
C***********************************************************************
      SUBROUTINE MC43QD(N,NNZ,NTOT,NODES,NSTRT,LSTNUM,IRN,ICPTR,NSVAR,
     +                 STATUS,NLIST,QUEUE,PRIOR)
C
C
C  PURPOSE:   RENUMBER NODES IN COMPONENT OF GRAPH FOR SMALL
C             WAVEFRONT AND PROFILE
C
C   N       - NUMBER OF NODES IN GRAPH = NUMBER OF SUPERVARIABLES
C           - UNCHANGED ON EXIT
C   NTOT    - TOTAL NUMBER OF VARIABLES IN THE PROBLEM
C           - UNCHANGED ON EXIT
C   NODES   - NUMBER OF NODES IN COMPONENT OF GRAPH
C           - UNCHANGED ON EXIT
C   NSTRT   - NUMBER OF NODE FOR STARTING RENUMBERING
C           - UNCHANGED ON EXIT
C   LSTNUM  - NUMBER OF NODES WHICH HAVE ALREADY BEEN RENUMBERED
C           - ON EXIT,NUMBER OF NODES WHICH HAVE BEEN RENUMBERED
C             (INPUT VALUE INCREMENTED BY NODES)
C   IRN     - ADJACENCY LIST FOR ALL NODES IN GRAPH
C           - UNCHANGED ON EXIT
C   ICPTR   - LIST OF POINTERS TO IRN
C           - NODES ADJACENT TO NODE 'I' ARE FOUND IN IRN(J), WHERE
C             J = ICPTR(I), ICPTR(I)+1, ..... , ICPTR(I+1)-1
C           - LIST OF LENGTH N+1 WHERE N IS THE TOTAL
C             NUMBER OF NODES IN THE GRAPH
C           - UNCHANGED ON EXIT
C   NSVAR   - INTEGER ARRAY OF LENGTH N.
C          - NSVAR(I) CONTAINS THE NUMBER OF VARIABLES IN SUPERVARIABLE
C            I (I=1,...,N)
C           - UNCHANGED ON EXIT
C   STATUS  - LIST GIVING THE DISTANCE OF EACH NODE IN THIS
C             COMPONENT FROM THE END NODE
C           - IF NODE 'I' IS IN THIS COMPONENT, THE DISTANCE OF
C             NODE 'I' FROM THE END NODE IS GIVEN BY STATUS(I)
C           - IF NODE 'I' IS IN A COMPONENT WHICH HAS ALREADY BEEN
C             RENUMBERED, THEN THE NEW NODE NUMBER FOR NODE 'I' IS
C             GIVEN BY -STATUS(I)
C           - IF NODE 'I' IS NOT IN THIS COMPONENT, AND THE COMPONENT
C             IS YET TO BE RENUMBERED, THEN STATUS(I)=1
C           - LIST OF LENGTH N WHERE N IS THE TOTAL NUMBER
C             OF NODES IN THE GRAPH
C           - ON EXIT, LIST GIVING THE NEW NODE NUMBERS FOR NODES WHICH
C             HAVE BEEN RENUMBERED
C           - NEW NUMBER FOR NODE 'I' IS -STATUS(I)
C   NLIST   - LIST OF NODES WHICH ARE IN THIS COMPONENT
C           - LIST OF LENGTH NODES
C   QUEUE   - QUEUE OF NODES WHICH ARE CURRENTLY ACTIVE OR PREACTIVE
C           - LIST OF MAX LENGTH NODES-1
C           - NOT DEFINED WHEN CALLING ROUTINE
C   PRIOR   - LIST OF PRIORITIES FOR EACH NODE
C           - FOR NODE 'I' WHICH IS CURRENTLY IN QUEUE, THE
C             PRIORITY OF NODE 'I' IS GIVEN BY PRIOR(I)
C           - LIST OF LENGTH N, WHERE N IS THE TOTAL NUMBER
C             OF NODES IN THE GRAPH
C           - NOT DEFINED WHEN CALLING ROUTINE
C
C NOTE:- NLIST AND QUEUE MAY OCCUPY SAME SPACE
C***********************************************************************
C
C
C     MAX CURRENT DEGREE FOR ANY GRAPH WITH N NODES IS N*NTOT
C
C     .. Parameters ..
      INTEGER W1,W2
      PARAMETER (W1=2,W2=1)
C     ..
C     .. Scalar Arguments ..
      INTEGER LSTNUM,N,NNZ,NODES,NSTRT,NTOT
C     ..
C     .. Array Arguments ..
      INTEGER ICPTR(N+1),IRN(2*NNZ),NLIST(NODES),NSVAR(N),PRIOR(N),
     +        QUEUE(NODES-1),STATUS(N)
C     ..
C     .. Local Scalars ..
      INTEGER ADDRES,DEGREE,I,ISTOP,ISTRT,J,JSTOP,JSTRT,K,MAXDEG,MAXPRT,
     +        NABOR,NBR,NEXT,NODE,NQ,PRTY,STANAB
C     ..
C     .. Executable Statements ..
C
C     INITIALISE PRIORITIES AND STATUS FOR EACH NODE IN THIS COMPONENT
C     INITIAL PRIORITY = -W1*DEGREE + W2*DIST
C     WHERE:
C     W1     = A POSITIVE WEIGHT
C     W2     = A POSITIVE WEIGHT
C     MAXDEG = MAX CURRENT DEGREE FOR ANY NODE IN GRAPH
C     DEGREE = INITIAL CURRENT DEGREE FOR NODE
C     DIST   = DISTANCE OF NODE FROM END NODE
C     INITIAL STATUS FOR ALL NODES IN THIS COMPONENT = 2
C
c      MAXDEG = NODES*NTOT
      MAXDEG = 0
      DO 20 I = 1,NODES
        NODE = NLIST(I)
        DEGREE = 1
        DO 10 J = ICPTR(NODE),ICPTR(NODE+1) - 1
          K = IRN(J)
          DEGREE = DEGREE + NSVAR(K)
   10   CONTINUE
        MAXDEG = MAX(MAXDEG,DEGREE)
        PRIOR(NODE) = -W1*DEGREE + W2*STATUS(NODE)
        STATUS(NODE) = 2
   20 CONTINUE
C
C     INSERT STARTING NODE IN QUEUE
C     ASSIGN IT A PREACTIVE STATUS
C     NQ IS THE SIZE OF QUEUE
C
      NQ = 1
      QUEUE(NQ) = NSTRT
      STATUS(NSTRT) = 1
C
C     LOOP WHILE QUEUE IS NOT EMPTY
C
   30 IF (NQ.GT.0) THEN
C
C       LOOP OVER EACH NODE IN QUEUE
C       PICK NODE WITH MAX PRIORITY
C
        MAXPRT = -W1*MAXDEG
        DO 40 I = 1,NQ
          PRTY = PRIOR(QUEUE(I))
          IF (PRTY.GT.MAXPRT) THEN
            ADDRES = I
            MAXPRT = PRTY
          END IF

   40   CONTINUE
C
C       NEXT IS THE NEXT NODE TO BE RENUMBERED
C
        NEXT = QUEUE(ADDRES)
C
C       DELETE NODE NEXT FROM QUEUE
C
        QUEUE(ADDRES) = QUEUE(NQ)
        NQ = NQ - 1
        ISTRT = ICPTR(NEXT)
        ISTOP = ICPTR(NEXT+1) - 1
        IF (STATUS(NEXT).EQ.1) THEN
C
C         NODE NEXT IS PREACTIVE
C         EXAMINE NEIGHBOURS OF NEXT
C
          DO 50 I = ISTRT,ISTOP
C
C           DECREASE CURRENT DEGREE OF NEIGHBOUR BY NSVAR(NEXT)
C
            NBR = IRN(I)
            PRIOR(NBR) = PRIOR(NBR) + W1*NSVAR(NEXT)
C
C           ADD NEIGHBOUR TO QUEUE IF IT IS INACTIVE
C           ASSIGN IT A PREACTIVE STATUS
C
            IF (STATUS(NBR).EQ.2) THEN
              NQ = NQ + 1
              QUEUE(NQ) = NBR
              STATUS(NBR) = 1
            END IF

   50     CONTINUE
        END IF
C
C       STORE -VE OF NEW NODE NUMBER FOR NODE NEXT
C       STATUS FOR NEXT IS NOW -LSTNUM
C
        LSTNUM = LSTNUM + 1
        STATUS(NEXT) = -LSTNUM
C
C       EXAMINE NEIGHBOURS OF NEXT
C
        DO 70 I = ISTRT,ISTOP
          NBR = IRN(I)
C
C         SKIP TO NEXT NEIGHBOUR IF NBR IS NOT PREACTIVE
C
          IF (STATUS(NBR).EQ.1) THEN
C
C           NEIGHBOUR IS CURRENTLY PREACTIVE
C           DECREASE ITS CURRENT DEGREE BY -1
C           ASSIGN IT AN ACTIVE STATUS
C
            PRIOR(NBR) = PRIOR(NBR) + W1
            STATUS(NBR) = 0
C
C           LOOP OVER NODES ADJACENT TO NBR
C
            JSTRT = ICPTR(NBR)
            JSTOP = ICPTR(NBR+1) - 1
            DO 60 J = JSTRT,JSTOP
              NABOR = IRN(J)
              STANAB = STATUS(NABOR)
              IF (STANAB.GE.0) THEN
C
C               NABOR IS NOT POSTACTIVE
C               DECREASE ITS CURRENT DEGREE BY NSVAR(NBR)
C
                PRIOR(NABOR) = PRIOR(NABOR) + W1*NSVAR(NBR)
                IF (STANAB.EQ.2) THEN
C
C                 NABOR IS CURRENTLY INACTIVE, BUT THIS NODE IS NOW
C                 ADJACENT TO A NEWLY ACTIVATED NODE
C                 INSERT NABOR IN QUEUE AND ASSIGN IT A PREACTIVE
C                 STATUS
C
                  NQ = NQ + 1
                  QUEUE(NQ) = NABOR
                  STATUS(NABOR) = 1
                END IF

              END IF

   60       CONTINUE
          END IF

   70   CONTINUE
        GO TO 30

      END IF
C
      RETURN

      END
C**********************************************************************
      SUBROUTINE MC43RD(N,NNZ,IPERM,IRN,ICPTR,IPROF)
C
C
C PURPOSE:COMPUTE THE PROFILES USING BOTH ORIGINAL AND NEW NODE NUMBERS
C
C N      - TOTAL NUMBER OF NODES IN GRAPH
C        - UNCHANGED ON EXIT
C IPERM  - LIST OF NEW NODE NUMBERS FOR GRAPH
C        - NEW NODE NUMBER FOR NODE 'I' IS GIVEN BY IPERM(I)
C        - LIST OF LENGTH N
C        - UNCHANGED ON EXIT
C IRN    - ADJACENCY LIST FOR ALL NODES IN GRAPH
C        - UNCHANGED ON EXIT
C ICPTR  - LIST OF POINTERS TO IRN
C        - NODES ADJACENT TO NODE 'I' ARE FOUND IN IRN(J), WHERE
C          J = ICPTR(I), ICPTR(I)+1, ..., ICPTR(I+1)-1
C        - LIST OF LENGTH N+1
C        - UNCHANGED ON EXIT
C IPROF  - NOT SET ON ENTRY
C        - ON EXIT, IPROF(1) IS PROFILE OF MATRIX FOR ORIGINAL ORDERING
C          IPROF(2) IS PROFILE OF MATRIX FOR NEW ORDERING
C
C NOTE: COMPUTED PROFILES INCLUDE DIAGONAL TERMS
C**********************************************************************
C
C     INITIALISE PROFILES TO ZERO
C
C     .. Scalar Arguments ..
      INTEGER N,NNZ
C     ..
C     .. Array Arguments ..
      INTEGER ICPTR(N+1),IPERM(N),IPROF(2),IRN(2*NNZ)
C     ..
C     .. Local Scalars ..
      INTEGER I,J,JSTOP,JSTRT,K1,NEWMIN,OLDMIN
C     ..
C     .. Intrinsic Functions ..
      INTRINSIC IDIM,MIN0
C     ..
C     .. Executable Statements ..
      DO 10 I = 1,2
        IPROF(I) = 0
   10 CONTINUE
C
C     LOOP OVER NODES IN GRAPH
C
      DO 30 I = 1,N
        JSTRT = ICPTR(I)
        JSTOP = ICPTR(I+1) - 1
C Following line added 3 March 1998 (needed since some variables
C may have no neighbours)
        IF (JSTOP.LE.JSTRT) GO TO 30

        OLDMIN = IRN(JSTRT)
        NEWMIN = IPERM(IRN(JSTRT))
C
C       FIND LOWEST NUMBERED NEIGHBOUR OF NODE I
C       (USING BOTH OLD AND NEW NODE NUMBERS)
C
        DO 20 J = JSTRT + 1,JSTOP
          K1 = IRN(J)
          OLDMIN = MIN0(OLDMIN,K1)
          NEWMIN = MIN0(NEWMIN,IPERM(K1))
   20   CONTINUE
C
C       CONTRIBUTION TO PROFILE IS POSITIVE DIFFERENCE BETWEEN
C       NODE NUMBER FOR NODE I AND LOWEST NUMBERED NEIGHBOUR
C
        IPROF(1) = IPROF(1) + IDIM(I,OLDMIN)
        IPROF(2) = IPROF(2) + IDIM(IPERM(I),NEWMIN)
   30 CONTINUE
C
C     ADD DIAGONAL TERMS TO PROFILES
C
      DO 40 I = 1,2
        IPROF(I) = IPROF(I) + N
   40 CONTINUE
      RETURN

      END
C*******************************************************************
      SUBROUTINE MC43SD(N,NELT,NZ,ELTVAR,ELTPTR,NORDER,LAST,IW,MFRNT)
C
C   FOR A GIVEN ELEMENT ORDER (CONTAINED IN NORDER) THIS ROUTINE
C   CALCULATES THE RESULTING MAXIMUM WAVEFRONT IN THE FRONTAL
C   SOLVER (ASSUMNING NO STABILITY RESTRICTIONS)
C
C*********************************************************************
C N     - INTEGER VARIABLE
C       - MUST BE SET TO THE LARGEST INTEGER USED TO INDEX A VARIABLE.
C       - THIS ARGUMENT IS NOT CHANGED.
C       - RESTRICTION : N_GE_1.
C NELT  - INTEGER VARIABLE
C       - MUST BE SET TO THE NUMBER OF ELEMENTS AND IS NOT CHANGED
C NZ    - INTEGER VARIABLE
C       - MUST BE SET TO THE ELTPTR(NELT+1)-1 AND IS NOT CHANGED
C ELTVAR - INTEGER ARRAY. ON ENTRY, MUST BE SET TO LISTS OF
C        - VARIABLES IN ELEMENTS. THOSE FOR ELEMENT 1 PRECEDE THOSE FOR
C        - ELEMENT 2 AND SO ON.  UNCHANGED ON EXIT
C ELTPTR - INTEGER ARRAY.  ON ENTRY, ELTPTR(J) MUST CONTAIN THE
C        - POSITION IN ELTVAR OF THE FIRST VARIABLE IN ELEMENT J
C        - (J=1,...,NELT) AND ELTADJ(NELT+1) MUST BE SET TO THE POSITION
C        - AFTER THE LAST VARIABLE OF THE LAST ELEMENT.  UNCHANGED ON
C        - EXIT.
C NORDER - INTEGER ARRAY OF LENTH NELT.
C        - MUST CONTAIN THE ELEMENT ORDER. UNCHANGED ON EXIT.
C LAST   - INTEGER ARRAY OF LENGTH N. USED AS WORKSPACE.
C        - ON EXIT, THE ENTRIES OF LAST INDICATE IN WHICH ELEMENT
C        - EACH VARIABLE APPEARS FOR THE LAST TIME.
C IW     - INTEGER ARRAY OF LENGTH N. USED AS WORKSPACE.
C MFRNT  - INTEGER VARIABLE. NOT SET ON ENTRY.
C        - ON EXIT, MFRNT IS SET TO THE MAX FRONTWIDTH IN THE FRONTAL
C        - SOLVER (ASSUMING NO STABILITY RESTRICTIONS) FOR THE GIVEN
C        - ELEMENT ORDER.
C*******************************************************************
C
C     .. Scalar Arguments ..
      INTEGER MFRNT,N,NELT,NZ
C     ..
C     .. Array Arguments ..
      INTEGER ELTPTR(NELT+1),ELTVAR(NZ),IW(N),LAST(N),NORDER(NELT)
C     ..
C     .. Local Scalars ..
      INTEGER I,IELT,J,JSTOP,JSTRT,JVAR,KFRNT,LFRNT
C     ..
C     .. Intrinsic Functions ..
      INTRINSIC MAX
C     ..
C     .. Executable Statements ..
C  INITIALISATION
      DO 10 I = 1,N
        LAST(I) = 0
        IW(I) = 0
   10 CONTINUE
      MFRNT = 0
C
C  DETERMINE WHEN EACH VARIABLE APPEARS FOR THE FINAL TIME
C
      DO 30 I = 1,NELT
        IELT = NORDER(I)
        JSTRT = ELTPTR(IELT)
        JSTOP = ELTPTR(IELT+1) - 1
        DO 20 J = JSTRT,JSTOP
          JVAR = ELTVAR(J)
          LAST(JVAR) = I
   20   CONTINUE
   30 CONTINUE
C
C CALCULATE  MAX WAVEFRONT
C (ASSUMING NO STABILITY RESTRICTIONS)
C
      KFRNT = 0
      DO 50 I = 1,NELT
        IELT = NORDER(I)
        JSTRT = ELTPTR(IELT)
        JSTOP = ELTPTR(IELT+1) - 1
        LFRNT = 0
        DO 40 J = JSTRT,JSTOP
          JVAR = ELTVAR(J)
          IF (IW(JVAR).EQ.0) THEN
C  JVAR IS ENTERING THE FRONT FOR THE FIRST TIME
            IW(JVAR) = 1
            KFRNT = KFRNT + 1
          END IF

          IF (LAST(JVAR).EQ.I) THEN
C  JVAR CAN BE ELIMINATED FROM THE FRONT
            IW(JVAR) = 0
            LFRNT = LFRNT + 1
          END IF

   40   CONTINUE
        MFRNT = MAX(MFRNT,KFRNT)
        KFRNT = KFRNT - LFRNT
   50 CONTINUE
      RETURN

      END
C*************************************************************
      BLOCK DATA MC43UD
C     .. Common blocks ..
      COMMON /MC43TD/LP,IWUSE(2)
      INTEGER LP
      INTEGER IWUSE
C     ..
C     .. Save statement ..
      SAVE /MC43TD/
C     ..
C     .. Data statements ..
      DATA LP/6/,IWUSE(1)/0/,IWUSE(2)/0/
C     ..
      END
