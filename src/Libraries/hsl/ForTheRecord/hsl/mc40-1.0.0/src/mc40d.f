* COPYRIGHT (c) 1988 AEA Technology
*######DATE 21 Sept 1994
C
C
      SUBROUTINE MC40AD(ITYPE,N,NNZ,IRN,JCN,ICPTR,IPERM,IW,IPROF,IFLAG)
C
C     ALGORITHM TO REDUCE THE PROFILE OF A SPARSE SQUARE MATRIX WITH A
C     SYMMETRIC SPARSITY PATTERN.
C     THE USER MUST SUPPLY THE PATTERN OF THE ENTRIES IN THE STRICTLY
C     LOWER TRIANGULAR PART OF THE MATRIX.
C
C     ITYPE - ON ENTRY, IF ITYPE=1, THE USER HAS SUPPLIED
C             THE STRICT LOWER TRIANGLE OF THE MATRIX IN
C             COORDINATE FORMAT
C             IF ITYPE=0, THE USER HAS INPUT THE STRICT LOWER
C             TRIANGLE OF THE MATRIX IN SPARSE COLUMN-WISE
C             FORMAT. Unchanged on exit.
C
C     N    - ORDER OF THE MATRIX
C          - RESTRICTION: N.GE.1. Unchanged on exit.
C
C     NNZ  - NNZ IS THE NUMBER OF ENTRIES IN THE STRICT
C            LOWER TRIANGLE OF THE MATRIX
C          - RESTRICTION: NNZ.GE.0. Unchanged on exit.
C
C     IRN  - INTEGER ARRAY OF LENGTH 2*NNZ
C          - ON ENTRY CONTAINS THE ROW INDICES OF THE
C            ENTRIES IN THE STRICT LOWER TRIANGLE OF THE
C            MATRIX. ON EXIT HOLDS
C            ADJACENCY LIST FOR ALL NODES IN THE MATRIX
C
C     JCN  - INTEGER ARRAY
C          - IF ITYPE=1, LENGTH OF ARRAY NNZ
C          - IF ITYPE=1, JCN CONTAINS THE COLUMN INDICES OF THE
C            ENTRIES IN THE STRICT LOWER TRIANGLE PART OF
C            THE MATRIX. DESTROTED BY ROUTINE.
C          - IF ITYPE=0, JCN IS NOT ACCESSED
C
C    ICPTR - INTEGER ARRAY OF LENGTH N+1
C          - IF ITYPE=1, ICPTR IS NOT SET ON ENTRY; IF ITYPE=0
C            ICPTR IS AN ARRAY SET SO THAT ICPTR(J) IS THE
C            POSITION IN THE ARRAY IRN OF THE FIRST ENTRY IN
C            COLUMN J (J=1,...,N)
C          - ON EXIT HOLDS LIST OF POINTERS TO  IRN
C          - NODES ADJACENT TO NODE I ARE FOUND IN IRN(J), WHERE
C            J = ICPTR(I), ICPTR(I)+1, ...,ICPTR(I+1)-1
C          - DEGREE OF NODE I GIVEN BY ICPTR(I+1)-ICPTR(I)
C
C    IPERM - INTEGER ARRAY OF LENGTH N
C          - NOT SET ON ENTRY
C          - ON EXIT HOLDS LIST OF THE NEW NODE NUMBERS
C          - NEW NODE NUMBER FOR NODE I GIVEN BY IPERM(I)
C
C     IW   - INTEGER ARRAY DEFINING WORKSPACE FOR RENUMBERING
C          - LENGTH 3*N+2
C
C     IPROF - INTEGER ARRAY OF LENGTH 2. NOT SET ON ENTRY
C             ON EXIT IPROF(1) - PROFILE FOR THE ORIGINAL ORDERING
C                     IPROF(2) - PROFILE FOR THE NEW ORDERING
C
C     IFLAG - INTEGER VARIABLE, NOT SET ON ENTRY. ERROR FLAG.
C           - IF IFLAG GT 0 A WARNING IS ISSUED BUT PROGRAM CONTINUES
C           - IF IFLAG LT 0 THE PROGRAM IS TERMINATED
C
C     .. Scalar Arguments ..
      INTEGER IFLAG,ITYPE,N,NNZ
C     ..
C     .. Array Arguments ..
      INTEGER ICPTR(N+1),IPERM(N),IPROF(2),IRN(2*NNZ),IW(3*N+2),JCN(*)
C     ..
C     .. Scalars in Common ..
      INTEGER LP,MP
C     ..
C     .. Local Scalars ..
      INTEGER I,IOUT,J,J1,JFLAG,KZ,L,NDIAG,OFDIAG
      LOGICAL YESA
C     ..
C     .. Local Arrays ..
      DOUBLE PRECISION A(1)
C     ..
C     .. External Subroutines ..
      EXTERNAL MC34AD,MC49AD,MC40BD
C     ..
C     .. Data block external statement
      EXTERNAL MC40KD
C     ..
C     .. Common blocks ..
      COMMON /MC40ID/LP,MP
C     ..
C     .. Save statement ..
      SAVE /MC40ID/
C     ..
      YESA = .FALSE.
      IFLAG = 0
C
C  CHECK INPUT PARAMETERS
C
      IF (N.LT.1) THEN
          IFLAG = -1
          IF (LP.GT.0) WRITE (LP,FMT=9000) IFLAG
          RETURN

      END IF

      IF (NNZ.LT.0) THEN
          IFLAG = -2
          IF (LP.GT.0) WRITE (LP,FMT=9000) IFLAG
          RETURN

      END IF
C
      IF (ITYPE.NE.0 .AND. ITYPE.NE.1) THEN
          IFLAG = -3
          IF (LP.GT.0) WRITE (LP,FMT=9000) IFLAG
          RETURN

      END IF
C
C  CHECK WHETHER THE MATRIX IS OF ORDER 1
C
      IF (N.EQ.1) THEN
          IPROF(1) = 1
          IPROF(2) = 1
          IPERM(1) = 1
          RETURN

      END IF
C
C  CHECK WHETHER THE MATRIX IS DIAGONAL. IF IT IS RETURN WITH
C  THE PROFILE EQUAL TO THE ORDER OF THE MATRIX
C
      IF (NNZ.EQ.0) THEN
          IPROF(1) = N
          IPROF(2) = N
          RETURN

      END IF
C
C  INITIALISE
C
      DO 10 I = 1,3*N + 2
          IW(I) = 0
   10 CONTINUE
C
C    CHECK THAT THE USER DID NOT SUPPLY SOME ENTRIES ON THE
C    DIAGONAL OR IN THE UPPER TRIANGLE OF THE MATRIX. IF THE
C    USER DID SUPPLY ENTRIES NOT IN THE LOWER TRIANGLE THEY ARE
C    IGNORED AND THE USER IS ISSUED WITH A WARNING MESSAGE.
C
C  ALSO CHECK THAT THE USER DID NOT SUPPLY ROW OR COLUMN INDICES
C  OUT OF RANGE (AGAIN, ANY SUCH ENTRIES ARE IGNORED).
C
      KZ = 0
      IOUT = 0
      NDIAG = 0
      OFDIAG = 0
      IF (ITYPE.EQ.0) THEN
          J1 = ICPTR(1)
          ICPTR(1) = 1
          DO 30 L = 1,N
              DO 20 J = J1,ICPTR(L+1) - 1
                  I = IRN(J)
                  IF (I.GT.N .OR. I.LT.1) IOUT = IOUT + 1
                  IF (I.EQ.L) NDIAG = NDIAG + 1
                  IF (I.LT.L) OFDIAG = OFDIAG + 1
                  IF (I.GT.L .AND. I.LE.N) THEN
                      KZ = KZ + 1
                      IRN(KZ) = I
                  END IF

   20         CONTINUE
              J1 = ICPTR(L+1)
              ICPTR(L+1) = KZ + 1
   30     CONTINUE

      ELSE
          DO 40 L = 1,NNZ
              I = IRN(L)
              J = JCN(L)
              IF (I.GT.N .OR. I.LT.1) IOUT = IOUT + 1
              IF (J.GT.N .OR. J.LT.1) IOUT = IOUT + 1
              IF (I.EQ.J) NDIAG = NDIAG + 1
              IF (I.LT.J) OFDIAG = OFDIAG + 1
              IF (J.GE.1 .AND. I.GT.J .AND. I.LE.N) THEN
                  KZ = KZ + 1
                  IRN(KZ) = I
                  JCN(KZ) = J
              END IF

   40     CONTINUE
      END IF
C
      IF (IOUT.GT.0) THEN
          IFLAG = 3

      ELSE IF (OFDIAG.GT.0) THEN
          IFLAG = 2

      ELSE IF (NDIAG.GT.0) THEN
          IFLAG = 1
      END IF

      IF (IFLAG.GT.0 .AND. MP.GT.0) WRITE (MP,FMT=9010) IFLAG
C
C  IF ITYPE=1 SORT THE ENTRIES TO AN ORDERING BY COLUMNS
C
      IF (ITYPE.EQ.1) THEN
          CALL MC49AD(-1,N,N,KZ,IRN,JCN,YESA,1,A,N+1,ICPTR,N+1,
     +               IW,JFLAG)
          DO 50 I = 1,N
              IW(I) = 0
   50     CONTINUE
      END IF
C
C  EXPAND MATRIX STRUCTURE
C
      CALL MC34AD(N,IRN,ICPTR,YESA,A,IW)
      DO 60 I = 1,N
          IW(I) = 0
   60 CONTINUE
C
C CALL THE RENUMBERING ALGORITHM
C
      CALL MC40BD(N,NNZ,IRN,ICPTR,IPERM,IW,IPROF)
C
      RETURN

 9000 FORMAT (/,3X,'ERROR MESSAGE: IFLAG = ',I2)
 9010 FORMAT (/,3X,'WARNING MESSAGE : IFLAG =',I2)

      END
C
      SUBROUTINE MC40BD(N,NNZ,IRN,ICPTR,IPERM,IW,IPROF)
C
C     RENUMBER A GRAPH FOR SMALL WAVEFRONT AND PROFILE
C
C     N,NNZ  - SEE MC40AD
C     IRN    - ADJACENCY LIST FOR ALL NODES IN GRAPH
C            - LIST OF LENGTH 2*NNZ. UNCHANGED ON EXIT.
C     ICPTR  - LIST OF LENGTH N+1 OF POINTERS TO IRN. SEE MC40AD.
C     IPERM - INTEGER ARRAY OF LENGTH N. NOT SET ON ENTRY
C           - ON EXIT, NEW NUMBERS CONTAINED IN IPERM(I) FOR I=1 TO N
C           - NEW NUMBER FOR NODE I GIVEN BY IPERM(I)
C           - IPERM CONTAINS ORIGINAL NODE NUMBERS IF THEY GIVE
C             A SMALLER PROFILE
C     IW    - INTEGER ARRAY DEFINING WORKSPACE FOR RENUMBERING
C           - LENGTH 3*N+2
C     IPROF - NOT SET ON ENTRY
C           - ON EXIT IPROF(1) - PROFILE USING ORIGINAL NODE ORDERING
C                     IPROF(2) - PROFILE FOR NEW NODE ORDERING
C             IF ORIGINAL NODE NUMBERS GIVE A SMALLER PROFILE,
C             THE BOTH ENTRIES IN IPROF ARE SET TO THE
C             ORIGINAL PROFILE
C
C     .. Scalar Arguments ..
      INTEGER N,NNZ
C     ..
C     .. Array Arguments ..
      INTEGER ICPTR(N+1),IPERM(N),IPROF(2),IRN(2*NNZ),IW(3*N+2)
C     ..
C     .. Local Scalars ..
      INTEGER DEGREE,I,LSTNUM,N1,N2,N3,NODES,NSTOP,NSTRT
C     ..
C     .. External Subroutines ..
      EXTERNAL MC40CD,MC40DD,MC40ED,MC40FD
C     ..
C     SET ALL NEW NODE NUMBERS = 1
C     THIS IS USED TO DENOTE ALL VISIBLE NODES
C
      DO 10 I = 1,N
          IPERM(I) = 1
   10 CONTINUE
C
C     SET LAST NEW NODE NUMBER
C
      LSTNUM = 0
C
C     RENUMBER ALL NODES OF DEGREE ZERO
C     STORE -VE OF NEW NODE NUMBER
C
      DO 20 I = 1,N
          DEGREE = ICPTR(I+1) - ICPTR(I)
          IF (DEGREE.EQ.0) THEN
              LSTNUM = LSTNUM + 1
              IPERM(I) = -LSTNUM
          END IF

   20 CONTINUE
C
C     LOOP WHILE SOME NODES REMAIN UNNUMBERED
C
   30 IF (LSTNUM.LT.N) THEN
C
C       FIND END POINTS OF P-DIAMETER FOR NODES IN THIS COMPONENT
C
          N1 = 1
          N2 = N1 + N - LSTNUM
          N3 = N2 + N + 1
          CALL MC40CD(N,NNZ,IRN,ICPTR,IPERM,IW(N1),IW(N2),IW(N2),IW(N3),
     +               NSTRT,NSTOP,NODES)
C
C       COMPUTE DISTANCES FROM END NODE AND ASSEMBLE LIST OF NODES
C       THAT ARE IN THIS COMPONENT
C
          N2 = N1 + NODES
          N3 = N2 + NODES + 1
          CALL MC40DD(N,NNZ,NSTOP,NODES,IRN,ICPTR,IPERM,IW(N1),IW(N2))
C
C       RENUMBER NODES IN THIS COMPONENT
C
          N3 = N2 + N
          CALL MC40ED(N,NNZ,NODES,NSTRT,LSTNUM,IRN,ICPTR,IPERM,IW(N1),
     +               IW(N1),IW(N2))
          GO TO 30

      END IF
C
C     SET NEW NODE NUMBERS TO +VE VALUES
C
      DO 40 I = 1,N
          IPERM(I) = -IPERM(I)
   40 CONTINUE
C
C     COMPUTE PROFILES FOR OLD AND NEW NODE NUMBERS
C
      CALL MC40FD(N,NNZ,IPERM,IRN,ICPTR,IPROF)
C
C     USE ORIGINAL NUMBERING IF NEW NUMBERING GIVES GREATER PROFILE
C
      IF (IPROF(2).GE.IPROF(1)) THEN
          DO 50 I = 1,N
              IPERM(I) = I
   50     CONTINUE
          IPROF(2) = IPROF(1)
      END IF
C
      RETURN

      END
C
      SUBROUTINE MC40CD(N,NNZ,IRN,ICPTR,MASK,LS,XLS,DEG,LIST,NSTRT,
     +                 NSTOP,NODES)
C
C     FIND NODES WHICH DEFINE A PSUEDO-DIAMETER OF A GRAPH
C
C N     - THE TOTAL NUMBER OF NODES IN THE GRAPH
C IRN   - ADJACENCY LIST FOR ALL NODES IN THE GRAPH
C ICPTR - LIST OF LENGTH N+1 OF POINTERS TO IRN
C MASK  - MASKING VECTOR OF LENGTH N FOR GRAPH
C       - VISIBLE NODES HAVE MASK = 1. NODE IS INVISIBLE OTHERWISE.
C LS    - LIST OF LENGTH N CONTAINING A ROOTED LEVEL STRUCTURE
C       - NOT SET ON ENTRY
C XLS   - LIST OF LENGTH N+1 POINTERS TO LS
C       - NODES IN LEVEL I ARE FOUND IN LS(J), WHERE
C         J = XLS(I), XLS(I)+1, ..., XLS(I+1)-1
C       - THE WIDTH OF LEVEL I IS GIVEN BY XLS(I+1)-XLS(I)
C       - NOT SET ON ENTRY
C DEG   - LIST OF LENGTH N DEGREES OF NODES ON BOTTOM
C         LEVEL OF ROOTED STRUCTURE
C       - NOT SET ON ENTRY
C LIST  - LIST OF LENGTH N OF NODES ON BOTTOM LEVEL OF
C         ROOTED LEVEL STRUCTURE
C       - NOT SET ON ENTRY
C NSTRT - NOT SET ON ENTRY. ON EXIT STARTING NODE FOR RENUMBERING.
C NSTOP - NOT SET ON ENTRY. ON EXIT END NODE FOR RENUMBERING
C NODES - NOT SET ON ENTRY. ON EXIT NUMBER OF NODES IN THIS
C         COMPONENT OF GRAPH
C
C     NOTES:
C     ------
C     - DEG AND XLS MAY OCCUPY SAME SPACE
C     - NSTRT AND NSTOP DEFINE A PSUEDO-DIAMETER OF THIS COMPONENT
C       OF THE GRAPH
C
C     .. Scalar Arguments ..
      INTEGER N,NNZ,NODES,NSTOP,NSTRT
C     ..
C     .. Array Arguments ..
      INTEGER DEG(N),ICPTR(N+1),IRN(2*NNZ),LIST(N),LS(N),MASK(N),
     +        XLS(N+1)
C     ..
C     .. Local Scalars ..
      INTEGER DEGREE,I,ID1,ID2,ISTOP,ISTRT,LSIZE,LWIDTH,MAXDEP,MINDEG,
     +        MINWID,NLSIZE,NLVL,NODE
C     ..
C     .. External Subroutines ..
      EXTERNAL MC40GD,MC40HD
C     ..
C     CHOOSE FIRST GUESS FOR STARTING NODE BY MIN DEGREE
C     IGNORE NODES THAT ARE INVISIBLE (MASK NE 1)
C
      MINDEG = N
      DO 10 I = 1,N
          IF (MASK(I).EQ.1) THEN
              DEGREE = ICPTR(I+1) - ICPTR(I)
              IF (DEGREE.LT.MINDEG) THEN
                  NSTRT = I
                  MINDEG = DEGREE
              END IF

          END IF

   10 CONTINUE
C
C     GENERATE LEVEL STRUCTURE FOR NODE WITH MIN DEGREE
C
      CALL MC40GD(NSTRT,N,N,NNZ,IRN,ICPTR,MASK,LS,XLS,MAXDEP,LWIDTH)
C
C     STORE NUMBER OF NODES IN THIS COMPONENT
C
      NODES = XLS(MAXDEP+1) - 1
C
C     ITERATE TO FIND START AND END NODES
C
   20 CONTINUE
C
C     STORE DEGREES OF NODES THAT ARE AT MAX DISTANCE FROM STARTING NODE
C
      ISTRT = XLS(MAXDEP)
      ISTOP = XLS(MAXDEP+1) - 1
      DO 30 I = ISTRT,ISTOP
          NODE = LS(I)
          DEG(NODE) = ICPTR(NODE+1) - ICPTR(NODE)
   30 CONTINUE
C
C     SORT LIST OF NODES IN ASCENDING SEQUENCE OF THEIR DEGREE
C     USE INSERTION SORT ALGORITHM (HOULSBY AND SLOAN)
C
      LSIZE = ISTOP - ISTRT + 1
      IF (LSIZE.GT.1) CALL MC40HD(N,LSIZE,LS(ISTRT),DEG)
C*******
C     STORE THE SORTED LIST
C
      ISTRT = ISTRT - 1
C     LSIZE=(LSIZE/2)+1
      DO 40 I = 1,LSIZE
          LIST(I) = LS(ISTRT+I)
   40 CONTINUE
C*******
      ID1 = DEG(LIST(1))
      NLSIZE = 1
      DO 50 I = 2,LSIZE
          ID2 = DEG(LIST(I))
          IF (ID2.NE.ID1) THEN
              NLSIZE = NLSIZE + 1
              LIST(NLSIZE) = LIST(I)
          END IF

          ID1 = ID2
   50 CONTINUE
C**********
C
C     LOOP OVER NODES IN LIST
C
      MINWID = NODES
      DO 60 I = 1,NLSIZE
          NODE = LIST(I)
C
C       FORM ROOTED LEVEL STRUCTURES FOR EACH NODE IN LIST
C
          CALL MC40GD(NODE,MINWID,N,NNZ,IRN,ICPTR,MASK,LS,XLS,NLVL,
     +               LWIDTH)
          IF (NLVL.GT.MAXDEP .AND. LWIDTH.LT.MINWID) THEN
C
C           LEVEL STRUCTURE OF GREATER DEPTH FOUND
C           STORE ROOT NODE AS STARTING NODE, NEW MAX DEPTH, AND BEGIN
C           A NEW ITERATION
C
              NSTRT = NODE
              MAXDEP = NLVL
              GO TO 20

          ELSE IF (LWIDTH.LT.MINWID) THEN
C
C             LEVEL STRUCTURE WIDTH FOR THIS END NODE IS SMALLEST
C             ENCOUNTERED SO FAR
C             STORE END NODE AND NEW MIN WIDTH
C
              NSTOP = NODE
              MINWID = LWIDTH
          END IF

   60 CONTINUE
C
      RETURN

      END
C
      SUBROUTINE MC40DD(N,NNZ,ROOT,NODES,IRN,ICPTR,MASK,LS,XLS)
C
C     ASSEMBLE LIST OF NODES IN SAME COMPONENT AS ROOT NODE
C     COMPUTE DISTANCES OF THESE NODES FROM ROOT NODE
C
C N,NNZ  - SEE MC40AD.
C ROOT   - THE ROOT NODE
C NODES  - THE NUMBER OF NODES IN SAME COMPONENT AS ROOT
C IRN    - ADJACENCY LIST FOR ALL NODES IN GRAPH
C ICPTR  - LIST OF POINTERS TO IRN
C MASK   - MASKING VECTOR OF LENGTH N FOR GRAPH
C        - VISIBLE NODES HAVE MASK = 1
C        - ON EXIT HOLDS DISTANCES OF NODES IN THIS COMPONENT FROM ROOT.
C        - THE DISTANCE OF NODE I IS GIVEN BY MASK(I)
C LS     - LENGTH NODES. NOT SET ON ENTRY.
C          ON EXIT HOLDS ROOTED LEVEL STRUCTURE,
C          (I.E. A LIST OF NODES IN THE SAME COMPONENT AS ROOT)
C XLS    - LENGTH NODES+1. NOT SET  ON ENTRY. ON EXIT HOLDS
C          LIST OF POINTERS TO LS
C        - NODES IN LEVEL I ARE FOUND IN LS(J), WHERE
C          J = XLS(I), XLS(I)+1, ..., XLS(I+1)-1
C
C     .. Scalar Arguments ..
      INTEGER N,NNZ,NODES,ROOT
C     ..
C     .. Array Arguments ..
      INTEGER ICPTR(N+1),IRN(2*NNZ),LS(NODES),MASK(N),XLS(NODES+1)
C     ..
C     .. Local Scalars ..
      INTEGER I,J,JSTOP,JSTRT,LWIDTH,NLVL
C     ..
C     .. External Subroutines ..
      EXTERNAL MC40GD
C     ..
C     GENERATE LEVEL STRUCTURE FOR ROOT NODE
      CALL MC40GD(ROOT,NODES,N,NNZ,IRN,ICPTR,MASK,LS,XLS,NLVL,LWIDTH)
C
C     STORE DISTANCES OF EACH NODE FROM ROOT NODE
C
      DO 20 I = 1,NLVL
          JSTRT = XLS(I)
          JSTOP = XLS(I+1) - 1
          DO 10 J = JSTRT,JSTOP
              MASK(LS(J)) = I - 1
   10     CONTINUE
   20 CONTINUE
C
      RETURN

      END
C
      SUBROUTINE MC40ED(N,NNZ,NODES,NSTRT,LSTNUM,IRN,ICPTR,STATUS,NLIST,
     +                 QUEUE,PRIOR)
C
C     RENUMBER NODES IN COMPONENT OF GRAPH FOR SMALL WAVEFRONT AND
C     PROFILE
C
C     INPUT:
C     ------
C
C     NODES    - NUMBER OF NODES IN COMPONENT OF GRAPH
C     NSTRT    - NUMBER OF NODE FOR STARTING RENUMBERING
C     LSTNUM   - NUMBER OF NODES WHICH HAVE ALREADY BEEN RENUMBERED
C     IRN      - ADJACENCY LIST FOR ALL NODES IN GRAPH
C     ICPTR    - LIST OF POINTERS TO IRN
C     STATUS   - LIST GIVING THE DISTANCE OF EACH NODE IN THIS
C                COMPONENT FROM THE END NODE
C              - IF NODE I IS IN THIS COMPONENT, THE DISTANCE OF
C                NODE I FROM THE END NODE IS GIVEN BY STATUS(I)
C              - IF NODE I IS IN A COMPONENT WHICH HAS ALREADY BEEN
C                RENUMBERED, THEN THE NEW NODE NUMBER FOR NODE I IS
C                GIVEN BY -STATUS(I)
C              - IF NODE I IS NOT IN THIS COMPONENT, AND THE COMPONENT
C                IS YET TO BE RENUMBERED, THEN STATUS(I)=1
C              - LIST OF LENGTH N WHERE N IS THE TOTAL NUMBER
C                OF NODES IN THE GRAPH
C     NLIST    - LIST OF NODES WHICH ARE IN THIS COMPONENT
C              - LIST OF LENGTH NODES
C     QUEUE    - QUEUE OF NODES WHICH ARE CURRENTLY ACTIVE OR PREACTIVE
C              - LIST OF MAX LENGTH NODES-1
C              - NOT DEFINED WHEN CALLING ROUTINE
C     PRIOR    - LIST OF PRIORITIES FOR EACH NODE
C              - FOR NODE I WHICH IS CURRENTLY IN QUEUE, THE
C                PRIORITY OF NODE I IS GIVEN BY PRIOR(I)
C              - LIST OF LENGTH N, WHERE N IS THE TOTAL NUMBER
C                OF NODES IN THE GRAPH
C              - NOT DEFINED WHEN CALLING ROUTINE
C
C     OUTPUT:
C     -------
C
C     NODES  - UNCHANGED
C     NSTRT  - UNCHANGED
C     LSTNUM - NUMBER OF NODES WHICH HAVE BEEN RENUMBERED
C                (INPUT VALUE INCREMENTED BY NODES)
C     IRN    - UNCHANGED
C     ICPTR  - UNCHANGED
C     STATUS - LIST GIVING THE NEW NODE NUMBERS FOR NODES WHICH
C                HAVE BEEN RENUMBERED
C              - NEW NUMBER FOR NODE I IS -STATUS(I)
C     NLIST  - NOT USED
C     QUEUE  - NOT USED
C     PRIOR  - NOT USED
C     NOTES:
C     ------
C
C     - NLIST AND QUEUE MAY OCCUPY SAME SPACE
C     - STATUS ALSO SERVES AS A LIST GIVING THE STATUS OF THE NODES
C       DURING THE RENUMBERING PROCESS:
C       STATUS(I) LT 0 INDICATES NODE I IS POSTACTIVE
C       STATUS(I) = 0 INDICATES NODE I IS CURRENTLY ACTIVE
C       STATUS(I) = 1 INDICATES NODE I IS PREACTIVE
C       STATUS(I) = 2 INDICATES NODE I IS INACTIVE
C
C     .. Parameters ..
      INTEGER W1,W2
      PARAMETER (W1=2,W2=1)
C     ..
C     .. Scalar Arguments ..
      INTEGER LSTNUM,N,NNZ,NODES,NSTRT
C     ..
C     .. Array Arguments ..
      INTEGER ICPTR(N+1),IRN(2*NNZ),NLIST(NODES),PRIOR(N),QUEUE(NODES),
     +        STATUS(N)
C     ..
C     .. Local Scalars ..
      INTEGER ADDRES,DEGREE,I,ISTOP,ISTRT,J,JSTOP,JSTRT,MAXDEG,MAXPRT,
     +        NABOR,NBR,NEXT,NODE,NQ,PRTY,STANAB
C     ..
C     MAX CURRENT DEGREE FOR ANY GRAPH WITH N NODES IS N
      MAXDEG = NODES
C
C     INITIALISE PRIORITIES AND STATUS FOR EACH NODE IN THIS COMPONENT
C     INITIAL PRIORITY = W1*(MAXDEG-DEGREE) + W2*DIST
C     WHERE:
C     W1     = A POSITIVE WEIGHT
C     W2     = A POSITIVE WEIGHT
C     MAXDEG = MAX CURRENT DEGREE FOR ANY NODE IN GRAPH
C     DEGREE = INITIAL CURRENT DEGREE FOR NODE
C     DIST   = DISTANCE OF NODE FROM END NODE
C     INITIAL STATUS FOR ALL NODES IN THIS COMPONENT = 2
C
      DO 10 I = 1,NODES
          NODE = NLIST(I)
          DEGREE = ICPTR(NODE+1) - ICPTR(NODE) + 1
          PRIOR(NODE) = W1* (MAXDEG-DEGREE) + W2*STATUS(NODE)
          STATUS(NODE) = 2
   10 CONTINUE
C
C     INSERT STARTING NODE IN QUEUE
C     ASSIGN IT A PREACTIVE STATUS
C     NQ IS THE SIZE OF QUEUE
C
      NQ = 1
      QUEUE(NQ) = NSTRT
      STATUS(NSTRT) = 1
C
C     LOOP WHILE QUEUE IS NOT EMPTY
C
   20 IF (NQ.GT.0) THEN
C
C       LOOP OVER EACH NODE IN QUEUE
C       PICK NODE WITH MAX PRIORITY
C
          MAXPRT = -1
          DO 30 I = 1,NQ
              PRTY = PRIOR(QUEUE(I))
              IF (PRTY.GT.MAXPRT) THEN
                  ADDRES = I
                  MAXPRT = PRTY
              END IF

   30     CONTINUE
C
C       NEXT IS THE NEXT NODE TO BE RENUMBERED
C
          NEXT = QUEUE(ADDRES)
C
C       DELETE NODE NEXT FROM QUEUE
C
          QUEUE(ADDRES) = QUEUE(NQ)
          NQ = NQ - 1
          ISTRT = ICPTR(NEXT)
          ISTOP = ICPTR(NEXT+1) - 1
          IF (STATUS(NEXT).EQ.1) THEN
C
C         NODE NEXT IS PREACTIVE
C         EXAMINE NEIGHBOURS OF NEXT
C
              DO 40 I = ISTRT,ISTOP
C
C           DECREASE CURRENT DEGREE OF NEIGHBOUR BY -1
C
                  NBR = IRN(I)
                  PRIOR(NBR) = PRIOR(NBR) + W1
C
C           ADD NEIGHBOUR TO QUEUE IF IT IS INACTIVE
C           ASSIGN IT A PREACTIVE STATUS
C
                  IF (STATUS(NBR).EQ.2) THEN
                      NQ = NQ + 1
                      QUEUE(NQ) = NBR
                      STATUS(NBR) = 1
                  END IF

   40         CONTINUE
          END IF
C
C       STORE -VE OF NEW NODE NUMBER FOR NODE NEXT
C       STATUS FOR NEXT IS NOW -LSTNUM
C
          LSTNUM = LSTNUM + 1
          STATUS(NEXT) = -LSTNUM
C
C       EXAMINE NEIGHBOURS OF NEXT
C
          DO 60 I = ISTRT,ISTOP
              NBR = IRN(I)
C
C         SKIP TO NEXT NEIGHBOUR IF NBR IS NOT PREACTIVE
C
              IF (STATUS(NBR).EQ.1) THEN
C
C           NEIGHBOUR IS CURRENTLY PREACTIVE
C           DECREASE ITS CURRENT DEGREE BY -1
C           ASSIGN IT AN ACTIVE STATUS
C
                  PRIOR(NBR) = PRIOR(NBR) + W1
                  STATUS(NBR) = 0
C
C           LOOP OVER NODES ADJACENT TO NBR
C
                  JSTRT = ICPTR(NBR)
                  JSTOP = ICPTR(NBR+1) - 1
                  DO 50 J = JSTRT,JSTOP
                      NABOR = IRN(J)
                      STANAB = STATUS(NABOR)
                      IF (STANAB.GE.0) THEN
C
C               NABOR IS NOT POSTACTIVE
C               DECREASE ITS CURRENT DEGREE BY -1
C
                          PRIOR(NABOR) = PRIOR(NABOR) + W1
                          IF (STANAB.EQ.2) THEN
C
C                 NABOR IS CURRENTLY INACTIVE, BUT THIS NODE IS NOW
C                 ADJACENT TO A NEWLY ACTIVATED NODE
C                 INSERT NABOR IN QUEUE AND ASSIGN IT A PREACTIVE
C                 STATUS
C
                              NQ = NQ + 1
                              QUEUE(NQ) = NABOR
                              STATUS(NABOR) = 1
                          END IF

                      END IF

   50             CONTINUE
              END IF

   60     CONTINUE
          GO TO 20

      END IF
C
      RETURN

      END
C
      SUBROUTINE MC40FD(N,NNZ,IPERM,IRN,ICPTR,IPROF)
C
C     COMPUTE THE PROFILES USING BOTH ORIGINAL AND NEW NODE NUMBERS
C
C     INPUT:
C     ------
C     N,NNZ - SEE MC40AD
C     IPERM - LIST OF NEW NODE NUMBERS FOR GRAPH
C              - NEW NODE NUMBER FOR NODE I IS GIVEN BY IPERM(I)
C              - LIST OF LENGTH N
C     IRN   - ADJACENCY LIST FOR ALL NODES IN GRAPH
C     ICPTR - LIST OF POINTERS TO IRN
C     IPROF - NOT SET ON ENTRY
C
C     OUTPUT:
C     -------
C     N,NNZ  - UNCHANGED
C     IPERM  - UNCHANGED
C     IRN    - UNCHANGED
C     ICPTR  - UNCHANGED
C     IPROF(1) - PROFILE OF MATRIX FOR ORIGINAL ORDERING
C     IPROF(2) - PROFILE OF MATRIX FOR NEW ORDERING
C
C     NOTES:
C     ------
C     - COMPUTED PROFILES INCLUDE DIAGONAL TERMS
C
C     .. Scalar Arguments ..
      INTEGER N,NNZ
C     ..
C     .. Array Arguments ..
      INTEGER ICPTR(N+1),IPERM(N),IPROF(2),IRN(2*NNZ)
C     ..
C     .. Local Scalars ..
      INTEGER I,J,JSTOP,JSTRT,K1,NEWMIN,OLDMIN
C     ..
C     .. Intrinsic Functions ..
      INTRINSIC DIM,MIN
C     ..
C     INITIALISE PROFILES TO ZERO
      DO 10 I = 1,2
          IPROF(I) = 0
   10 CONTINUE
C
C     LOOP OVER NODES IN GRAPH
C
      DO 30 I = 1,N
          JSTRT = ICPTR(I)
          JSTOP = ICPTR(I+1) - 1
          OLDMIN = I
          NEWMIN = IPERM(I)
C
C       FIND LOWEST NUMBERED NEIGHBOUR OF NODE I
C       (USING BOTH OLD AND NEW NODE NUMBERS)
C
          DO 20 J = JSTRT,JSTOP
              K1 = IRN(J)
              OLDMIN = MIN(OLDMIN,K1)
              NEWMIN = MIN(NEWMIN,IPERM(K1))
   20     CONTINUE
C
C       CONTRIBUTION TO PROFILE IS POSITIVE DIFFERENCE BETWEEN
C       NODE NUMBER FOR NODE I AND LOWEST NUMBERED NEIGHBOUR
C
          IPROF(1) = IPROF(1) + DIM(I,OLDMIN)
          IPROF(2) = IPROF(2) + DIM(IPERM(I),NEWMIN)
   30 CONTINUE
C
C     ADD DIAGONAL TERMS TO PROFILES
C
      DO 40 I = 1,2
          IPROF(I) = IPROF(I) + N
   40 CONTINUE
C
      RETURN

      END
C
      SUBROUTINE MC40GD(ROOT,MAXWID,N,NNZ,IRN,ICPTR,MASK,LS,XLS,NLVL,
     +                 LWIDTH)
C
C     GENERATE ROOTED LEVEL STRUCTURE USING A FORTRAN 77 IMPLEMENTATION
C     OF THE ALGORITHM GIVEN BY GEORGE AND LUI
C
C     INPUT:
C     ------
C     ROOT   - ROOT NODE FOR LEVEL STRUCTURE
C     MAXWID - MAX PERMISSIBLE WIDTH OF ROOTED LEVEL STRUCTURE
C              - ASSEMBLY OF LEVEL STRUCTURE ABORTED IF ANY LEVEL HAS
C                WIDTH WHICH IS GE THIS VALUE
C              - ASSEMBLY ENSURED BY SETTING MAXWID = NODES, WHERE
C                NODES IS THE NUMBER OF NODES IN COMPONENT
C     IRN    - ADJACENCY LIST FOR ALL NODES IN GRAPH
C     ICPTR  - LIST OF POINTERS TO IRN
C     MASK   - MASKING VECTOR FOR GRAPH
C              - VISIBLE NODES HAVE MASK = 1
C              - LIST OF LENGTH N, WHERE N IS THE TOTAL
C                NUMBER OF NODES IN THE GRAPH
C     LS     - NOT SET
C     XLS    - NOT SET
C     NLVL   - NOT SET
C     LWIDTH - NOT SET
C
C     OUTPUT:
C     -------
C     ROOT   - UNCHANGED
C     MAXWID - UNCHANGED
C     IRN    - UNCHANGED
C     ICPTR  - UNCHANGED
C     MASK   - UNCHANGED
C     LS     - LIST CONTAINING A ROOTED LEVEL STRUCTURE
C            - LIST OF LENGTH NODES
C     XLS    - LIST OF POINTERS TO LS
C            - NODES IN LEVEL I ARE FOUND IN LS(J), WHERE
C              J = XLS(I), XLS(I)+1, ..., XLS(I+1)-1
C            - LIST OF MAX LENGTH NODES+1
C     NLVL   - NUMBER OF LEVELS IN ROOTED LEVEL STRUCTURE
C     LWIDTH - WIDTH OF ROOTED LEVEL STRUCTURE
C
C     .. Scalar Arguments ..
      INTEGER LWIDTH,MAXWID,N,NLVL,NNZ,ROOT
C     ..
C     .. Array Arguments ..
      INTEGER ICPTR(N+1),IRN(2*NNZ),LS(N),MASK(N),XLS(N+1)
C     ..
C     .. Local Scalars ..
      INTEGER I,J,JSTOP,JSTRT,LBEGIN,LNBR,LVLEND,LVSIZE,NBR,NODE
C     ..
C     .. Intrinsic Functions ..
      INTRINSIC MAX
C     ..
C     INITIALISATION
C
      MASK(ROOT) = 0
      LS(1) = ROOT
      NLVL = 0
      LVLEND = 0
      LNBR = 1
      LWIDTH = 1
      LVSIZE = 1
   10 IF (LVSIZE.GT.0) THEN
          LWIDTH = MAX(LVSIZE,LWIDTH)
C
C       ABORT CONSTRUCTION IF LEVEL STRUCTURE HAS WIDTH GE MAXWID
C
          IF (LWIDTH.GE.MAXWID) THEN
              GO TO 40

          END IF
C
C       LBEGIN POINTS TO BEGINNING OF PRESENT LEVEL
C       LVLEND POINTS TO END OF PRESENT LEVEL
C
          LBEGIN = LVLEND + 1
          LVLEND = LNBR
          NLVL = NLVL + 1
          XLS(NLVL) = LBEGIN
C
C       GENERATE NEXT LEVEL BY FINDING ALL UNMASKED NEIGHBOURS
C       OF NODES IN PRESENT LEVEL
C
          DO 30 I = LBEGIN,LVLEND
              NODE = LS(I)
              JSTRT = ICPTR(NODE)
              JSTOP = ICPTR(NODE+1) - 1
              DO 20 J = JSTRT,JSTOP
                  NBR = IRN(J)
                  IF (MASK(NBR).EQ.1) THEN
                      LNBR = LNBR + 1
                      LS(LNBR) = NBR
                      MASK(NBR) = 0
                  END IF

   20         CONTINUE
   30     CONTINUE
          LVSIZE = LNBR - LVLEND
          GO TO 10

      END IF

      XLS(NLVL+1) = LVLEND + 1
C
C     RESET MASK=1 FOR NODES IN THE LEVEL STRUCTURE
C
   40 CONTINUE
      DO 50 I = 1,LNBR
          MASK(LS(I)) = 1
   50 CONTINUE
C
      RETURN

      END
C
      SUBROUTINE MC40HD(N,NL,LIST,KEY)
C
C     ORDER A LIST OF INTEGERS IN ASCENDING SEQUENCE OF THEIR KEYS
C
C     INPUT:
C     ------
C     N,NL - INTEGERS GIVING LENGTH OF KEY AND LIST
C     LIST - A LIST OF LENGTH NL OF INTEGERS
C     KEY  - A LIST OF LENGTH N OF INTEGER KEYS
C
C     OUTPUT:
C     -------
C     N,NL - UNCHANGED
C     LIST - A LIST INTEGERS SORTED IN ASCENDING
C            SEQUENCE OF THEIR INTEGER KEYS
C     KEY  - UNCHANGED
C
C     NOTES:
C     ------
C
C     - USES INSERTION SORT
C     - EFFICIENT ONLY FOR N VALUES LESS THAN ABOUT 12 (ALTHOUGH
C       MAY BE SYSTEM DEPENDENT) AS DISCUSSED IN HOULSBY AND SLOAN

C     .. Scalar Arguments ..
      INTEGER N,NL
C     ..
C     .. Array Arguments ..
      INTEGER KEY(N),LIST(NL)
C     ..
C     .. Local Scalars ..
      INTEGER I,J,K,VALUE
C     ..
C     FIND INTEGER WITH SMALLEST KEY AND PUT IT AT HEAD OF LIST
      J = 1
      K = LIST(1)
      VALUE = KEY(K)
      DO 10 I = 2,NL
          IF (KEY(LIST(I)).LT.VALUE) THEN
              J = I
              VALUE = KEY(LIST(I))
          END IF

   10 CONTINUE
      LIST(1) = LIST(J)
      LIST(J) = K
C
C     CARRY OUT INSERTION SORT
C
      DO 30 I = 2,NL
          J = I
          K = LIST(I)
          VALUE = KEY(K)
   20     IF (VALUE.LT.KEY(LIST(J-1))) THEN
              LIST(J) = LIST(J-1)
              J = J - 1
              GO TO 20

          END IF

          LIST(J) = K
   30 CONTINUE
      END
C
      BLOCK DATA MC40KD
C     .. Scalars in Common ..
      INTEGER LP,MP
C     ..
C     .. Common blocks ..
      COMMON /MC40ID/LP,MP
C     ..
C     .. Save statement ..
      SAVE /MC40ID/
C     ..
C     .. Data statements ..
      DATA LP/6/,MP/6/
C     ..
      END
